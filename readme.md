# Intel SD Training 

## Table of contents
+ **[ Day 0 - System/Tool Setup Check. GitHub ID creation ](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmarkday-0)**
  <details><summary> Theory </summary>
  
  [Theory - System/Tool Setup Check. GitHub ID creation](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---systemtool-setup-check-github-id-creation)
  </details>
  <details><summary> Lab </summary>
  
  * [ Lab -Setup Labs](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2lab---setup-labs)
  </details>
  
- **[ Day 1 - Introduction to Verilog RTL design and Synthesis](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-1)**
  <details><summary> Theory </summary>
  
  [Theory - Introduction to Verilog RTL design and Synthesis](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---introduction-to-verilog-rtl-design-and-synthesis)
  
  </details>
  <details><summary> Lab </summary>
  
  * [Lab Topic- Labs using iverilog and gtkwave](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#lab---sky130rtl-d1sk2-l1-lab1-introduction-to-lab) 
  * [Lab Topic- Labs using Yosys and Sky130 PDKs](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic--labs-using-yosys-and-sky130-pdks) 

  </details>
  
+ **[ Day 2 - Timing libs(QTMs/ETMs), hierarchical vs flat synthesis and efficient flop coding styles](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-2)**
  <details><summary> Theory </summary>
    
   [Theory - Timing libs(QTMs/ETMs), hierarchical vs flat synthesis and efficient flop coding styles](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---timing-libsqtmsetms-hierarchical-vs-flat-synthesis-and-efficient-flop-coding-styles)
    
  </details>
  <details><summary> Lab </summary>
  
  * [Lab Topic - Introduction to timing .libs](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---introduction-to-timing-libs)
  * [Lab Topic - Hierarchical vs Flat Synthesis](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---hierarchical-vs-flat-synthesis)
  * [Lab Topic - Various Flop Coding Styles and optimization](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---various-flop-coding-styles-and-optimization)
  * [Lab Topic - Various Flop Coding Styles and optimization](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---various-flop-coding-styles-and-optimization-1)
  
   </details>
  
- **[ Day 3 - Combinational and sequential optmizations](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-3)**
  <details><summary> Theory </summary>
    
    [Theory - Combinational and sequential optmizations]()
    
  </details>
  <details><summary> Lab </summary>
  
  * [Lab Topic - SKY130RTL D3SK2 - Combinational logic optimizations](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---sky130rtl-d3sk2---combinational-logic-optimizations)
  * [Lab Topic - Sequential logic optimizations](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---sequential-logic-optimizations)
  * [Lab Topic - Sequential optimzations for unused outputs](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---sequential-optimzations-for-unused-outputs)
  
  </details>
  
+ **[ Day 4 - GLS, blocking vs non-blocking and Synthesis-Simulation mismatch](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-4))**
  <details><summary> Theory </summary>
    
   [Theory - GLS, blocking vs non-blocking and Synthesis-Simulation mismatch](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---gls-blocking-vs-non-blocking-and-synthesis-simulation-mismatch)
    
  </details>
  <details><summary> Lab </summary>
  
  * [Lab Topic - Labs on GLS and Synthesis-Simulation Mismatch](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---labs-on-gls-and-synthesis-simulation-mismatch)
  
  </details>
 
 
- **[ Day 5 - DFT(Design for Testability)](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-5)**
  
  <details><summary> Theory </summary>
    
  * [Theory - DFT (Design for Testability)](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---dft-design-for-testability)
    
  </details>
 
  
+ **[ Day 6 - Introduction to Logic Synthesis](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-6)**
  <details><summary> Theory </summary>
    
  * [Theory - Introduction to Logic Synthesis](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---introduction-to-logic-synthesis)
  * [Theory - Introduction to Design Compiler (DC)](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---introduction-to-design-compiler-dc)
  * [Theory - TCL quick refresher](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---tcl-quick-refresher)
    
  </details>
  <details><summary> Lab </summary>
  
  * [Lab Topic - Introduction to Logic Synthesis](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---introduction-to-logic-synthesis)

  </details>
  
  
+ **[ Day 7 - Basic of STA](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-7)**
  <details><summary> Theory </summary>
    
  * [Theory - Introduction to STA](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---introduction-to-sta)
  * [Theory - What are constraints?](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---what-are-constraints)
  * [Theory - Inp Trans Output Load](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---inp-trans-output-load)
    
  </details>
  <details><summary> Lab </summary>
  
  * [Lab Topic - Basics of STA](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---basics-of-sta)
    
  </details>
 
  
+ **[ Day 8 - Advanced sdc constraints](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-8)**
  <details><summary> Theory </summary>
    
  * [Theory - SDC Part1 Clock - Clock Tree Modelling - Uncertainty](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---sdc-part1-clock---clock-tree-modelling---uncertainty)
  * [Theory - SDC Part3 generated_clk](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---sdc-part3-generated_clk)

    
  </details>
  <details><summary> Lab </summary>
  
  * [Lab Topic - Advanced constraints](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---advanced-constraints)
    
  </details>
  
  
+ **[ Day 9 - Optimization in synthesis](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-9)**
  <details><summary> Theory </summary>
  
  * [Theory - Optimizations Combinational Opt](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---optimizations-combinational-opt)
  * [Theory - Sequential Optimizations](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---sequential-optimizations)
  * [Theory - Special optimizations](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---special-optimizations)
 
  
  </details>
  <details><summary> Lab </summary>
  
  * [Lab Topic - Combinational optimizations](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---combinational-optimizations)
  
  </details>  
  
  
+ **[ Day 10 -QOR](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-10)**
  <details><summary> Theory </summary>
   
  
  * [Theory - Lecture Report timing](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---lecture-report-timing)
 
  </details>
  <details><summary> Lab </summary>
  
  * [Lab Topic - Lab Report timing](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---lab-report-timing)
  
  </details>  
  
  
+ **[ Day 11 -Introduction to Baby SoC](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-11)**
  <details><summary> Theory </summary>
   
  
  * [Theory - Introduction to Baby SoC](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---introduction-to-baby-soc)
 
  </details>
  
 
+ **[ Day 12 - BabySoC Modelling](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-12)**
  <details><summary> Theory </summary>
   
  
  + [Theory - BabySoC Modelling](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---babysoc-modelling)

  </details>  
  
  <details><summary>  Lab  </summary>
  
    * [Lab Topic - VSDbabySoC Modelling](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---vsdbabysoc-modelling)
   
  </details>    
  
+ **[ Day 13 -Post-synthesis simulation](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-13)**
  <details><summary> Theory </summary>
   
  
  * [Theory - Post-synthesis simulation](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---post-synthesis-simulation)

   
  </details>  
  
  <details><summary>  Lab  </summary>
    
    * [Lab Topic - RVMYTH-AVSDDAC Pre-synthesis and Post-synthesis simulation](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic---rvmyth-avsddac-pre-synthesis-and-post-synthesis-simulation)
    
    
+ **[ Day 14 - Synopsys DC and timing analysis](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-14)**
  <details><summary> Theory </summary>
  
  * [Theory - Synopsys DC and timing analysis](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory----synopsys-dc-and-timing-analysis)
   
  </details>  
  
  <details><summary>  Lab  </summary>
    
    * [Lab Topic - PVT Table of Different Lib](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab-topic----pvt-table-of-different-lib)
    
  </details>  
    
+ **[ Day 15 - Inception of EDA and PDK](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bookmark-day-15)**
  <details><summary> Theory </summary>
   
  * [Theory - How to talk to computers](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---how-to-talk-to-computers)
  * [Theory - SoC design and OpenLANE](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---soc-design-and-openlane)
   
  </details>  
  
  <details><summary>  Lab  </summary>
    
    * [Lab - Get familiar to open-source EDA tools](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab---get-familiar-to-open-source-eda-tools)
    
  </details>  
    
+ **[ Day 16 - Good floorplan vs bad floorplan and introduction to library cells]()**
  <details><summary> Theory </summary>
   
  * [Theory - Chip Floor planning considerations](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---chip-floor-planning-considerations)
  * [Theory - Library Binding and Placement](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---library-binding-and-placement)
  * [Theory - Cell design and characterization flows](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---cell-design-and-characterization-flows)
  * [Theory - General timing characterization parameters](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---general-timing-characterization-parameters)
    
  </details>  
  
  <details><summary>  Lab  </summary>
    
    * [Lab - Chip Floor planning considerations](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab---chip-floor-planning-considerations)
    
  </details>  
    
+ **[ Day 17 - Design library cell using Magic Layout and ngspice characterization]()**
  <details><summary> Theory </summary>
   
  * [Theory - Labs for CMOS inverter ngspice simulations](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---labs-for-cmos-inverter-ngspice-simulations)
  * [Theory - Inception of Layout Â CMOS fabrication process](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---inception-of-layout-%C3%A2-cmos-fabrication-process)
    
  </details>  
  
  <details><summary>  Lab  </summary>
    
  * [Lab - Labs for CMOS inverter ngspice simulations](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab----labs-for-cmos-inverter-ngspice-simulations)
  * [Lab - Inception of Layout Â CMOS fabrication process](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab----inception-of-layout-%C3%A2-cmos-fabrication-process) 
  * [Lab - Sky130 Tech File Labs](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab---sky130-tech-file-labs)  
    
  </details>  
    
+ **[ Day 18 - Pre-layout timing analysis and importance of good clock tree]()**
  <details><summary> Theory </summary>
   
  * [Theory - Timing modelling using delay tables](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---timing-modelling-using-delay-tables)
  * [Theory - Timing analysis with ideal clocks using openSTA](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---timing-analysis-with-ideal-clocks-using-opensta)  
  * [Theory - Clock tree synthesis TritonCTS and signal integrity](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---clock-tree-synthesis-tritoncts-and-signal-integrity)
  * [Theory - Timing analysis with real clocks using openSTA](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---timing-analysis-with-real-clocks-using-opensta)
    
  </details>  
  
  <details><summary>  Lab  </summary>
    
  * [Lab - Timing modelling using delay tables](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab---timing-modelling-using-delay-tables) 
  * [Lab - Timing analysis with ideal clocks using openSTA](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab---timing-analysis-with-ideal-clocks-using-opensta)    
  * [Lab - Clock tree synthesis TritonCTS and signal integrity](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab---clock-tree-synthesis-tritoncts-and-signal-integrity)  
  * [Lab- Timing analysis with real clocks using openSTA](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab--timing-analysis-with-real-clocks-using-opensta)  
    
  </details>  
    
+ **[ Day 19 - Final steps for RTL2GDS using tritonRoute and openSTA]()**
  <details><summary> Theory </summary>
   
  * [Theory - Routing and design rule check (DRC)](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---routing-and-design-rule-check-drc)
  * [Theory - TritonRoute Features](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#bulb-theory---tritonroute-features)  

  </details>  
  
  <details><summary>  Lab  </summary>
    
  * [Lab - Power Distribution Network and routing](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab---power-distribution-network-and-routing) 
  * [Lab - TritonRoute Features](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#pencil2-lab---tritonroute-features)    

  </details>   
    
    
    
    
    
    
    
    
    
## :bookmark:	Day 0
### :bulb: Theory - System/Tool Setup Check. GitHub ID creation

<details><summary> Package </summary>
 
### **Package**
Package is a container that holds die and was connected to outside (external device) by using wire bonding.
Example of package - Quadruple in-line package (QIP) and Dual in-line package (DIP).

![die](https://user-images.githubusercontent.com/62828746/203833674-a44e1aa2-42f1-43eb-8890-016e0bc186e1.png)

* **Pad** - used to connect inside (core) to outside (I/O), good at ESD protection to prevent charge coming from outside damage the core inside.
* **Core** - consists of all the main logic gate (NMOS/PMOS) and cell block such as macro cell and foundry IP's.
* **I/O** - help in communication between die with external and will be connected to die by using wire bonding.

+ **Differences of macro vs foundry IP's**:
  * **Macro** - a simple core/cell with simple functionality and can be easily found online.
  * **Foundry IP's** - cell with more specific functionality and the design was patent/owned by a company. Has higher value compared to macro.
  
  </details>

<details><summary> How does a software communicate with hardware</summary>

### **How does a software communicate with hardware**
**Synthesis process** will help to convert software's instructions which is written in high level language to gate level language/machine language which is normally in binary format.

![software to hardware](https://user-images.githubusercontent.com/62828746/203840905-0b291241-5af6-40d1-9f6a-a8acb8176b7d.png)
 
**Synthesis process flow**:
1. **Specification/instructions** written in RTL (**high-level language** such as C, C++ or Java) as inputs.
1. **Compiler** will compile the instruction into **assembly language** (.exe).
1. **Assembler** will then convert **assembly language** into **gate level language** (low-level language.machine language) which is in binary format (operands), and it is the language understood by a computer.

   </details>

### :pencil2:	Lab - Setup Labs

<details><summary> Steps to enable labs </summary>
 
#### Steps to enable labs:

* [Day0 Lab Steps](https://intel-my.sharepoint.com/:u:/r/personal/huifen_teoh_intel_com/Documents/Desktop/Intel_SD_Training/Lab/Day0_lab.msg?csf=1&web=1&e=Kat8QI)

#### Result:

![Day0 Lab Result](https://user-images.githubusercontent.com/62828746/203844716-f72c32ab-2353-4f42-bbd2-c3bb49c88ecb.PNG)
 
   </details>


## :bookmark: Day 1
### :bulb: Theory - Introduction to Verilog RTL design and Synthesis

<details><summary> HDL (Hardware description Language) </summary>

### **HDL (Hardware description Language)**
* It is a language that used to model electronic circuit/system by describing their structure and behavior precisely.
* Commonly used in the design and verification of digital circuit.
* Most widely used and well-supported HDL used in industry: **Verilog** and VHDL (VHSIC Hardware Description Language)
* HDL code can be written in 3 model/levels of abstraction. (Behavioural, RTL and Gate-level)
   </details>
 
<details><summary> RTL Design (Register Transfer Level) </summary>
  
### **RTL Design (Register Transfer Level)**
* It's a design abstraction which models the signal flow between hardware registers and also the logical operations that performed on those signals.
* RTL written in Verilog decribes how signal is changed as it passed from register to register. 
* In shorts, HDL is a language used to decribe circuit's specification (structure and bahaviour) while RTL is a way of describing the circuit. 
   </details>
 
<details><summary> Synthesis </summary>
 
### **Synthesis**
* Synthesis tool (synthesizer) will turning an abstract design (**RTL**) into a correctly implmented chip in term of logic gates (**netlist**).
* Translation - Translate Verilog that describe design specification/functionality into basic logic gates.
* Mapping - Map logic gates to actual technology dependent logic gate that are readily avaiable in tech file.
* Optimization - Optimized mapped netlist while maintaining design's specification/functionality.

   </details>

<details><summary> Testbench </summary>
 
### **Testbench**

![testbench](https://user-images.githubusercontent.com/62828746/205500508-8e14ec1a-86b0-443f-aa71-f6570a717609.jpg)

* **Testbench** - is a setup to apply stimulus to the design and check whether the output meet required functionality and specification.
* **Stimulator** - it will apply stimulus to design input (stimulus generator) and obseve stimulus from design output (stimulus observer).
* **Design** - a verilog code/ a set of verilog codes that has intended functionality to meet required specification (Ex: an inverter).

   </details>

<details><summary> iVerilog (Icarus Verilog) Based RTL Design Simulation Flow </summary>
 
### **iVerilog (Icarus Verilog) Based RTL Design Simulation Flow**

**iVerilog** - is an open source verilog simulator tool that used to check design specification is adherence to RTL design or not.

![iVerilog Based Simulation Flow_1a](https://user-images.githubusercontent.com/62828746/205515413-06107299-7637-4000-a983-5ab9c8d46210.jpg)

1. **RTL design** and **testbench** are applied to iVerilog as inputs.
2. **iVerilog** simulating the design while any changes in value will be generated as VCD file.
3. **GTKwave** which is a graphic application helps in viewing the waveform.
4. Through the waveform, we can observe whether the input and output meet design specification. 

   </details>

<details><summary> yosys (Yosys Open SYnthesis Suite) Based Synthesis Flow </summary>
 
### **yosys (Yosys Open SYnthesis Suite) Based Synthesis Flow**

**yosys** is a framework for RTL synthesis tools that is used to convert RTL to netlist.

![yosys synthesizer_0](https://user-images.githubusercontent.com/62828746/205504038-a06b8354-b6de-4f03-96fe-faca348a5c34.jpg)

* **Design** - it's a behaviour verilog code.
* **.lib** - a collection of standard cell/logical modules. It includes basic logic gates (Ex: AND,OR,NAND,NOR) of different flavor such as number of inputs, speeds (slow, medium or fast) and functionality.
* **Netlist** - it's the representation of design in term of standard cell stored in the .lib.

   </details>

 <details><summary> iVerilog (Icarus Verilog) Based Synthesized Netlist Simulation Flow </summary>
  
### **iVerilog (Icarus Verilog) Based Synthesized Netlist Simulation Flow**

To confirm the netlist generated in synthesis is meet the requirement, will need to verify the netlist by using the simulator tool.

![iVerilog Based Synthesized Netlist Simulation Flow_0](https://user-images.githubusercontent.com/62828746/205505409-509251fa-7141-44ae-9b70-05ff0b15d704.jpg)

**Simulation flow** and the **outputs waveform** for both RTL design and synthesized netlist will be the same. The only difference is the inputs (RTL design[.v] or synthesized netlist[netlist.v]).

1. **Netlist** and **testbench** are applied to iVerilog as inputs.
2. **iVerilog** simulating the design while any changes in value will be generated as VCD file.
3. **GTKwave** which is a graphic application helps in viewing the waveform.
4. Through the waveform, we can observe whether the input and output meet design specification. 

   </details>
 
 <details><summary> How Flavours of Gate Effect Ciruit Operation Speed </summary>
  
### **How Flavours of Gate Effect Ciruit Operation Speed**

Combinational delay in logic path determine the maximum operation speed of digital logic circuit.

![Flavours of Gate (Fast vs Slow)](https://user-images.githubusercontent.com/62828746/205507225-0ab7c70d-3752-4aa8-8e97-dcf57d984a3f.jpg)

* The **minimum clock period** must be larger than the total time taken for propogation delay in both DFF A and combinational logic and setup time in DFF B.
* Minimum clock period signal let signals have enough time to travel from DFF A to DFF B.
* Better performance circuit must have **low clock period** and **high clock frequency**, so that operation speed will be higher.
* High speed standard cells can help in reduce propogation delay and thus reduce overall clock period.
* However, high speed cells might cause DFF B capture signal too fast and missed the data that supposed to catch.
* For this reason, hold time is required to have minimum delay from DFF A to DFF B.
* Slower cells can help in meeting the required hold time.
* In shorts, we need **fast cells to meet required performance** and also need **slow cells to meet minimum hold time**.

   </details>

<details><summary> How Capacitance Effect Circuit's Speed* </summary>
 
### **How Capacitance Effect Circuit's Speed**

![How Capacitance Effect Circuit's Speed](https://user-images.githubusercontent.com/62828746/205509103-b8a090bb-48eb-4854-abff-5e7c4500ab87.jpg)

* **Capacitance** - it's a load in digital logic ciruit. Faster charging/discharging rate will reduce cell delay and make cell A to drive cell B faster.
* **Transistor** - Wider transistor has higher capable of sourcing larger current and will result in faster capacitance charging/discharging rate. However, will wider transistor will consume larger area and power.

* In shorts, faster cells need to trade off with **area and power**.

   </details>

<details><summary> Cell Selection and Trade Off </summary>
  
### **Cell Selection and Trade Off**

Synthesizer required **constraints** as guidance in cell selection to select correct cell flavour that is optimum for logic circuit implementation.

Trade Off for Fast Cell                          | Trade off for Slow Cell
---------------------------------------------    | --------------------------------------------- 
Bad ciruit in term of area and power             | Slow speed circuit
Concern in hold time violation                   | Failed required performance

  </details>

### :pencil2: Lab Topic- Labs using iverilog and gtkwave

<details><summary> Lab1 introduction to lab </summary>

#### Steps:

> 1. Clone directory "sky130RTLDesignAndSynthesisWorkshop" from Kunal's github.
> > *git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git*
> 2. Explore copied directory and confirm there's all the required folders and files.
> > *cd sky130RTLDesignAndSynthesisWorkshop/*
> 3. Goto my_lib/ to explore stored verilog model.
> > *cd my_lib/*
> 4. Goto lib/ and make sure "sky130_fd_sc_hd__tt_025C_1v80.lib" lib is inside.
> > *cd lib/*
> 5. Goto verilog_files which stored all the verilog and testbench fill that will be used in subsequent labs.
>> *cd verilog_files/*

#### Result:
![SKY130RTL D1SK2 L1 Lab1 introduction to lab_result](https://user-images.githubusercontent.com/62828746/205509273-3c3774d7-75c2-4293-8306-29d9af55b0c8.jpg)

  </details>
 
### :pencil2: Lab Topic- Labs using Yosys and Sky130 PDKs
  
<details><summary> Lab2 Introduction iverilog gtkwave part1 </summary>
  
Related with theory part: [iVerilog (Icarus Verilog) Based RTL Design Simulation Flow](https://github.com/teoh5128/intel-sd-training/edit/main/readme.md#iverilog-icarus-verilog-based-synthesized-netlist-simulation-flow)

#### Steps:
> 1. Take good_mux cell as example. Run simulation by apply RTL Design (good_mux.v) and testbench (tb_good_mux.v) as inputs.
> > *iverilog good_mux.v tb_good_mux.v*
> 2. a.out file is now created, then exectue a.out file to dump vcd file.
> > *./a.out*

#### Result:
![SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part1_result_1](https://user-images.githubusercontent.com/62828746/205509351-9d96c79a-bd4b-4f1e-b1cb-4f00a4f974c0.jpg)

#### Steps:
> 1. Load generated vcd file in graphic application, GTKwave.
> > *gtkwave tb_good_mux.vcd*
> 2. Review waveform in GTKwave after pull all the signals to "signal" column and zoom to fit.

![SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part1_result_2_a](https://user-images.githubusercontent.com/62828746/205514717-bdef7d9c-0f8a-4c13-a65e-58a95c6f1df0.jpg)
  </details>
  
<details><summary> Lab2 Introduction iverilog gtkwave part2  </summary>

#### Steps:
> 1. Explore verilog file and testbench file to compare it with generated waveform.
>> *vim tb_good_mux.v -o good_mux.v*
> 2. Review generated waveform, result must follow all the specification in verilog and testbench.

#### Result:
![SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2_result_1](https://user-images.githubusercontent.com/62828746/205509398-b41f44e7-e9e7-445a-8a4d-e79a5a9e11bf.jpg)
*Testbench contains design instantiation (UUT) and will not have primary inputs/outputs assigned.*

![SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2_result_3_0](https://user-images.githubusercontent.com/62828746/205514404-3c9b3de8-51e6-4135-9a5a-41bcff2d1d22.jpg)
*Testbench contains stimulus to generate waveform such as input initial value and triggered period.*

![SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2_result_4_0](https://user-images.githubusercontent.com/62828746/205514407-834c9498-e069-4f39-98bb-5c7279cc45b5.jpg)
*After 50ns, sel is triggered, hence output will follow i0 value, y=1.*

![SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2_result_5_0](https://user-images.githubusercontent.com/62828746/205514403-96f1e1e3-26bb-436a-ada1-e415a13627ab.jpg)
*After 75ns, sel is triggered, hence output will follow i1 value, y=0.*

  </details>

<details><summary> Lab3 Yosys 1 good mux Part1 </summary>
 
Related with theory part: [yosys (Yosys Open SYnthesis Suite) Based Synthesis Flow](https://github.com/teoh5128/intel-sd-training/edit/main/readme.md#yosys-yosys-open-synthesis-suite-based-synthesis-flow)

#### Steps:
> 1. Invoke synthesizer tools, yosys
>> *yosys*
> 2. Read the library
>> *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
> 3. Read the design. there should no error and will see "successfully finished verilog frontend" printed.
>> *read_verilog good_mux.v*
> 4. Link to the module name that want to be synthesized.
>> *synth -top good_mux*
> 5. Generate netlist, "abc" is the command which will convert rtl file into gate specified in the library "sky130_fd_sc_hd__tt_025C_1v80.lib".
>> *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
> 6. To see graphical version of the logic it does realized.
>> *show*

#### Result:
![SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part1_result_1_0](https://user-images.githubusercontent.com/62828746/205514365-a1c5b714-5856-4f31-8220-0ede601699a9.jpg)
*Total inputs, library version used and total outputs shown in graphic should be the same with the ABC results.*
  </details>
 
<details><summary> Lab3 Yosys 1 good mux Part2 </summary>

#### Steps:
> 1. Load verilog file and review it togther with graphical version of the logic.
>> *!vim good_mux_netlist.v*

#### Result:
![SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part1_result_1_0_0](https://user-images.githubusercontent.com/62828746/205514500-9fedde6a-dd2c-4a7a-b86a-094072f3f2a5.jpg)
*mux2_1 is a multiplexer that will switch two input lines to a single common output line.*
     
  </details>

<details><summary> Lab3 Yosys 1 good mux Part3 </summary>
 
#### Steps:
> 1. To write out synthesized netlist
>> *write_verilog good_mux_netlist.v*
> 2. To write out synthesized netlist in more simplified way.
>> *write_verilog -noattr good_mux_netlist.v*

#### Result:
![SKY130RTL D1SK4 L3 Lab3 Yosys 1 good mux Part3_result_0_0](https://user-images.githubusercontent.com/62828746/205514343-4116c058-f43d-449d-8772-dda8f0572d92.jpg)
*With no attribute switch, a more simplified netlist (without cell instantiation) will be generated.*
    
  </details>


## :bookmark: Day 2
### :bulb: Theory - Timing libs(QTMs/ETMs), hierarchical vs flat synthesis and efficient flop coding styles

<details><summary> Cell Library Characterization </summary>
  
## **Cell Library Characterization**
* Cell library characterization important for moedeling standard cells in library.
* Models suitable for each chip implementations flows are different due to variations.
* Standard cell characterization used for collection cell's information such as leakage power, area, pins and timing.
* Synthesis tools need to know cell logic function, load, speed of cell under variation, power consumed, area and etc to synthesize behavioral description for standard cells.
* Even variation exist will effect cell's performance, but we need to make Silicon die works well in every corner.

  </details>

<details><summary> PVT </summary>
 
## **PVT**
* Cells behavior strongly depends on factors such as PVT, input signals and output load.
* To make fabricated chips working in all possible condition, stimulate it at different corners of process, voltage and temperature.
* While looking at best and worst PVT conditions allows us to predict lower and upper limitation of cell bahvior which are important to ensure the overall functionality of the design.


P (Process)                                      | V (Voltage)                                    | T (Temperature)
---------------------------------------------    | ---------------------------------------------  | --------------------------------------------- 
Different task or die area (center/boundary) has different process variation during fabrication | IR drop or supply noise might cause voltage variation. Even supplied voltage might not be stable all the time |  Density of transistor is inconsistent throughout the chip and resulting in power dissipation and temperature variation across the chip

  </details>

 
<details><summary> Hierachical and Flat Synthesis </summary>
  
## **Hierachical and Flat Synthesis**

Content   | Hierachical Synthesis | Flat Synthesis
---| --------------------  | -------------------- 
Definitions | Contains more than one module inside entire design. Each modules has interdependencies and have signals travelling between modules. | Contains only one module for entire design. It's a set of flat schematics and has no module interdependencies.
Pros | Sub-modules pins are accessible, it's easier to track path during functional debugging and timing analysis.  | Synthesis tool can optimize the circuit for better speed, area and power. 
Cons | Might cause issues when synthesize large design with massive sub-modules. | Debugging capabilities are limited.
Prefered | Prefered for human read-ability and debug purposes | Prefered when design has massive sub_modules, can synthezie one of it and stitch each netlist into top-level netlist.

  </details>

<details><summary> Glitch </summary>

## **Glitch**
* For combinational logic, propagation delay will cause output glitch.
* **Glitch** is unwanted and must be fixed.

![Glitch](https://user-images.githubusercontent.com/62828746/206111766-51f85c9d-62fd-4a7e-a331-9750b338ed2e.jpg)

  </details>

<details><summary> DFF </summary>
  
## **DFF**
* To fix glitch we need an element to store value periodically.
* **D Flip-flop** - acts as an electronic memory component since the output remains constant unless deliberately changed by altering the state of the D input at the given edge of clock.

![glitch combi](https://user-images.githubusercontent.com/62828746/206115287-75f6b5b8-5554-4464-9063-b0a9d8635d4c.jpg)
* Combinational circuit for sure will have output glitch due to logic gate propagational delay.
* Continous combitional circuit will even cause output continously has glitchy output and never settle down.

![stable combi](https://user-images.githubusercontent.com/62828746/206115291-cb106a81-7ce0-43f9-ab94-e0edf2e222b8.jpg)
* To avoid that, insert DFF for each combinational circuit.
* DFF shielded from D through clock, which means Q will only change whenever clk edge rise/fall and will not effcted by D.
* Even input is glitch, output of DFF will become stable and feed stable signal to next combinational circuit.


  </details>

<details><summary> Different type of flop and function </summary>
  
## **Different type of flop and function**
* Initial state of flip-flop is importtant to avoid next combinational logic grab and evaluate flip-flop value that are not yet initialized.
* Initialze of flip flop included set, reset, synchronous and asynchronous.

![asyn_dff](https://user-images.githubusercontent.com/62828746/206149008-ab6e106a-de71-4be7-a552-d327920d37b9.jpg)
* In **asynchronous reset**, the Flip Flop will not wait for the clock and sets the output right at the edge of the reset.
* Fast implmentation cause no need to wait for clock signal to be applied.

![sync_dff](https://user-images.githubusercontent.com/62828746/206149022-31e6c2b9-a46c-444c-89e1-e0c60325e8f3.jpg)
* In **synchronous Reset**, the Flip Flop waits for the next edge of the clock ( rising or falling), before applying the Reset of Data.
* If duration of rising edge of clock and reset edge is too short might causing metastability issues.
* DFF must have certain minimum time between reset edge and clock edge, which is reset recovery time. 

![asyn_sync_dff](https://user-images.githubusercontent.com/62828746/206149017-a90fa6d4-1492-46da-9d63-c432c00a727e.jpg)
* If both **aysnchronous reset and synchronous** reset are used, asynchronous reset has higher priority compared to synchronous reset.

  </details>
  

### :pencil2: Lab Topic - Introduction to timing .libs

<details><summary> Lab4 Introduction to dot Lib part1 </summary>

#### Steps:
> 1. Open library file and review what contains in .lib file. [*DO NOT EDIT .LIB FILE, ONLY READ]
>> *vim /lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
> 2. Tips to switch off syntax for more pleasant review experience. 
>> *:syn off*
> 3. Look into the information contains in .lib, such as library name, power, voltage and temperature of cell.

#### Result:

![SKY130RTL D2SK1 L1 Lab4 Introduction to dot Lib part1_result](https://user-images.githubusercontent.com/62828746/205701093-f65384e7-3f54-4ad0-b684-2d55bac72677.jpg)
*PVT information in .lib are important variations for a design to work.*

  </details>
 

<details><summary> Lab4 Introduction to dot Lib part2 </summary>

#### Steps:
> 1. There are various type of standard cells inside .lib file, we will see each cell features inside .lib.
>> *refer to resut_1.jpg*
> 2. To understand cell functionality, can review its equivalent verilog model.
>> *:sp ../my_lib/verilog_model/*
> 3. Delay and leakage power for all possible combitional inputs for a cell are also listed inside .lib.
>> *refer to result_2.jpg*

#### Result:
![SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part2_0a](https://user-images.githubusercontent.com/62828746/205701105-9d011958-99a0-49aa-9948-bd993caf6c6d.jpg)

*resut_1*

![SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part2_1a](https://user-images.githubusercontent.com/62828746/205701108-a5bf7783-2d6f-49f1-9864-7d5cbe98d6df.jpg)

*resut_2*

![SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part2_2a](https://user-images.githubusercontent.com/62828746/205701110-67e8a486-fd22-4e4b-9c24-6cb99faf31f3.jpg)

  </details>
  
<details><summary> Lab4 Introduction to dot Lib part3 </summary>
  
Related with theory part: [How Capacitance Effect Circuit's Speed](https://github.com/teoh5128/intel-sd-training/blob/main/readme.md#how-capacitance-effect-circuits-speed)

#### Steps:
> 1. Same cell type with different flavour will have different value in leakage power and area.
>> *:vsp*

#### Result:
![SKY130RTL D2SK1 L3 Lab4 Introduction to dot Lib part3_result_0a](https://user-images.githubusercontent.com/62828746/205701114-6f4f12b9-da8b-4143-b160-bcab608269d4.jpg)
*Faster cell with higher power has larger transistor, and will trade off with area consumed.*

  </details>
  
### :pencil2: Lab Topic - Hierarchical vs Flat Synthesis

<details><summary> Lab05 Hier synthesis flat synthesis part1 </summary>

#### Steps:
> 1.Take multiple_modules as example, may load multiple_modules.v file and review it's sub-module functionality.
>> *vim multiple_modules.v*
> 2. Run synthesis to see how top modules and sub-modules synthesis result make differences.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog multiple_modules.v*
>> * *synth -top multiple_modules*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show multiple_modules*
>> * *write_verilog -noattr multiple_modules_hier.v*
> 3. Open and review generated netlist.
>> * *!vim multiple_modules_hier.v*
>> * *refer to result_2.jpg*

#### Result:
![SKY130RTL D2SK2 L1 Lab05 Hier synthesis flat synthesis part1_result](https://user-images.githubusercontent.com/62828746/205941637-f46452bf-1c33-4c2a-9520-ec809fe51dd7.jpg)

![SKY130RTL D2SK2 L1 Lab05 Hier synthesis flat synthesis part1_result_0](https://user-images.githubusercontent.com/62828746/205940021-e3550d9f-5d2f-4093-abc5-bbf904e1ecc0.jpg)

*Instead of AND and OR logic gate, we see U1 and U2, this is the hierachical design*

![SKY130RTL D2SK2 L1 Lab05 Hier synthesis flat synthesis part1_result_1](https://user-images.githubusercontent.com/62828746/205940035-aca88f85-7eeb-4b22-adb1-09a46b43664d.jpg)

*result_2.jpg*

  </details>
  
<details><summary> Lab05 Hier synthesis flat synthesis part2 </summary>

#### Steps:
> 1. Use command to write out flat netlist.
>> * *flatten*
>> * *write_verilog -noattr multiple_modules_flat.v*
> 2. Open and review generated netlist.
>> *!vim multiple_modules_flat.v*
> 3. Instead of multiple_modules, now try to do a sub-module level synthesis.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
>> * *read_verilog multiple_modules.v*
>> * *synth -top sub_module1*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:

![SKY130RTL D2SK2 L2 Lab05 Hier synthesis flat synthesis part2_0](https://user-images.githubusercontent.com/62828746/205951977-f5421835-b178-46d7-9fc5-6129d4cb07f0.jpg)

![SKY130RTL D2SK2 L2 Lab05 Hier synthesis flat synthesis part2_1](https://user-images.githubusercontent.com/62828746/205951986-657e5cee-aefa-4a79-9738-0303eba015ea.jpg)

![SKY130RTL D2SK2 L2 Lab05 Hier synthesis flat synthesis part2_2](https://user-images.githubusercontent.com/62828746/205951994-b0a98ae0-f52c-4d5e-baef-206a4ab6cb30.jpg)

  </details>

### :pencil2: Lab Topic - Various Flop Coding Styles and optimization
  
<details><summary> Lab flop synthesis simulations part1 </summary>

#### Steps:
> 1. Take asynchronous reset flip flop as example. Run simulation by apply RTL Design (dff_asyncres.v) and testbench (tb_dff_asyncres.v) as inputs.
>> * *iverilog dff_asyncres.v tb_dff_asyncres.v*
>> * *./a.out*
>>  *gtkwave tb_dff_asyncres.vcd*
> 2. Take synchronous reset flip flop as example. Run simulation by apply RTL Design (dff_syncres.v) and testbench (tb_dff_syncres.v) as inputs.
>> * *iverilog dff_syncres.v tb_dff_syncres.v
>> * *./a.out*
>> * *gtkwave tb_dff_syncres.vcd*

#### Result:
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part1_0](https://user-images.githubusercontent.com/62828746/206079681-127eb22e-f0fd-4a01-8ba5-6c99e106ab35.jpg)
*asynchronous reset flip flop waveform*
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part1_1](https://user-images.githubusercontent.com/62828746/206079656-679d86f4-36e9-49f9-9add-94d2acdd0d80.jpg)
*asynchronous reset flip flop waveform*
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part1_2](https://user-images.githubusercontent.com/62828746/206079660-462b73df-ad21-476a-a32b-8c75b3a49aed.jpg)
*synchronous reset flip flop waveform*
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part1_3](https://user-images.githubusercontent.com/62828746/206079666-3ba2f68f-6a04-430d-aa37-8d51ac88a8aa.jpg)
*synchronous reset flip flop waveform*

  </details>
  
<details><summary> Lab flop synthesis simulations part2 </summary>
  
#### Steps:
> 1. We have done simulation of flip flop in part1, now run synthesis for asynchronous_reset flip flop and see the netlist.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog dff_asyncres.v*
>> * *synth -top dff_asyncres*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib -> this will make it only looking for flip flop standard cell in .lib*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

> 2. Read asynchronous_set flip flop netlist.
>> * *read_verilog dff_async_set.v*
>> * *synth -top dff_async_set*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

> 3. Read synchronous_reset flip flop netlist.
>> * *read_verilog dff_syncres.v*
>> * *synth -top dff_syncres*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part2_0](https://user-images.githubusercontent.com/62828746/206079667-6627f537-235f-4f98-98dd-49e506b7e50a.jpg)
*Command dfflibmap used will only looking for flip flop standard cell in .lib file.*
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part2_1](https://user-images.githubusercontent.com/62828746/206079670-39d2ba3f-005f-4d7a-b9a6-0e71333b4d8c.jpg)
*Differences of asynchronous_reset with asynchronous_set*
![SKY130RTL D2SK3 L4 Lab flop synthesis simulations part2_2](https://user-images.githubusercontent.com/62828746/206079674-bc8452b9-4bfa-4194-a0ed-22dc56f95deb.jpg)
*Synchronous_reset flip flop grapgical block*

  </details>
  
### :pencil2: Lab Topic - Various Flop Coding Styles and optimization
<details><summary> SKY130RTL D2SK3 L5 Interesting optimisations part1 </summary>
  
#### Steps:
1. Run multiplexer_2 synthesis and review it's netlist and grpahical block.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib* 
>> * *read_verilog mult_2.v*
>> * *synth -top dff_asyncres*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*
>> * *write_verilog -noattr mul2_net.v*

#### Result:
![SKY130RTL D2SK3 L5 Interesting optimisations part1_0](https://user-images.githubusercontent.com/62828746/206079676-189935c3-e858-4d57-8684-16880b3f6a6b.jpg)

  </details>
  
<details><summary>  Interesting optimisations part2 </summary>
  
#### Steps:
1. Run multiplexer_8 synthesis and review it's netlist and grpahical block.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog mult_8.v*
>> * *synth -top mult8*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*
>> * *write_verilog -noattr mul8_net.v*

#### Result:
![SKY130RTL D2SK3 L5 Interesting optimisations part1_1](https://user-images.githubusercontent.com/62828746/206079678-c3a23b3d-59c1-4b40-bb79-010964f8ae09.jpg)

  </details>

## :bookmark: Day 3
### :bulb: Theory - Combinational and sequential optmizations

<details><summary> Optimisation of Synthesis Tools </summary>
  
## **Optimisation of Synthesis Tools**
* When device library cells are instantiated, **synthesis tools do not optimize them by default**. 
* Even when instructed to optimize the device library cells, synthesis tools generally cannot perform the same level of optimization as with the RTL. 
* Therefore, synthesis tools typically **only perform optimizations on the paths to and from these cells** but not through the cells.
* Synthesis optmization helps to reduce circuit delay by reduce gate count without effecting original logic to meet timing constraints.
* Synthesis tool perform optimization by minimize cost function.
* **Cost function** comes in various flavour depend on EDA tool vendor.
* Two of the important cost function to minimize: time related and delay cost. 
  </details>

<details><summary> Constant propagation </summary>
  
## **Constant propagation**
* Constant propagation - a process of substituting the constant value of variables in the expression.
* It is one of the local code optimization technique for compiler.
  </details>

<details><summary> Combinational vs Sequential optimization </summary>
  
## **Combinational vs Sequential optimization**
Key          | Combinational Circuit                                   | Sequential Circuit
-------------    | ---------------------------------------------  | ------------------
Definition | Combinational Circuit is the type of circuit in which output is independent of time and only relies on the current input. |Sequential circuit is the type of circuit where output relies on both current input and also previous output. 
Optimization | constant propagation is Boolean algebra. | constant propagation is Boolean algebra + timing.
  </details>

<details><summary> Boolean Logic Optimisation </summary>
  
## **Boolean Logic Optimisation**
* **logic optimisation** improves simulation efficiency by simplyfy a complex boolean expression to simpler one which would ultimately produce same result.
* **Boolean algebra** refers to symbolic manipulation of expressions made up of boolean variables and boolean operators.
* **Axioms of Boolean algebra** : identity, commutative, distributive, and associative

<img width="615" alt="Boolean algebra" src="https://user-images.githubusercontent.com/62828746/206801948-d9fdeb1b-aafc-47d1-aeeb-e4574b9eba88.png">

*Axioms of Boolean algebra [reference from: 7.1   Boolean Logic](https://introcs.cs.princeton.edu/java/71boolean/)*

<img width="516" alt="identities" src="https://user-images.githubusercontent.com/62828746/206801941-30dd7c69-dcfc-457a-8eb3-8d89be6ee89b.png">

*Laws of Boolean Algebra [reference from: 7.1   Boolean Logic](https://introcs.cs.princeton.edu/java/71boolean/)*
  </details>

<details><summary> Boundary Optimisation </summary>
  
## **Boundary Optimisation**
*  Boundary optimisation is the optimisation undergo across boundary. 
*  Boundary optimisation including conatant optimization across hierarhies, remove unloaded logic connected, collapse equal and opposite pins, rewiring of equivalent signals across hierarchy and etc.
*  For example: Boundary optimisation will remove unused buffers that are inserted for allowing signal out of the module, then it will replace an inverters to see is it good enough for signal going out.
  </details>

### :pencil2: Lab Topic - SKY130RTL D3SK2 - Combinational logic optimizations

<details><summary> SKY130RTL D3SK2 L1 Lab06 Combinational Logic Optimisations part1 </summary>
  
### :pencil2: Lab - SKY130RTL D3SK2 L1 Lab06 Combinational Logic Optimisations part1

#### Steps:
> 1. Review optimization verilog file (opt_check.v and opt_check2.v).
>> *ls *opt_check**
>> *gvim opt_check.v*
>> *gvim opt_check2.v*
> 2. Run synthesis for opt_check.v and review it's netlist and grpahical block.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog opt_check.v*
>> * *synth -top opt_check*
>> * *opt_clean -purge-> command to do the optimization such as constant propagation*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*
> 3. Run synthesis for opt_check2.v and review it's netlist and grpahical block.
>> * *read_verilog opt_check2.v*
>> * *synth -top opt_check2*
>> * *opt_clean -purge-> command to do the optimization such as constant propagation*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK2 L1 Lab06 Combinational Logic Optimisations part1_0](https://user-images.githubusercontent.com/62828746/206799590-79949c0b-a29b-4ed3-aea5-67b5adeae60c.jpg)

*Review opt_check.v and opt_check2.v file.*
![SKY130RTL D3SK2 L1 Lab06 Combinational Logic Optimisations part1_1](https://user-images.githubusercontent.com/62828746/206799599-febe29b7-b91a-4ca9-8b0c-a1da420e26c9.jpg)

*An AND gate was inferred in the circuit as expected*
![SKY130RTL D3SK2 L1 Lab06 Combinational Logic Optimisations part1_2](https://user-images.githubusercontent.com/62828746/206799603-7f31f792-c06a-4538-b4f1-b9e7f35b89b4.jpg)

*An OR gate was inferred in the circuit as expected*

  </details>

<details><summary> Lab06 Combinational Logic Optimisations part2 </summary>
  
#### Steps:
> 1. Review third optimization verliog file (opt_check3.v).
> 2. Run synthesis for opt_check3.v and review it's netlist and grpahical block.
>> * *read_verilog opt_check3.v*
>> * *synth -top opt_check3*
>> * *opt_clean -purge-> command to do the optimization such as constant propagation*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations part2_0](https://user-images.githubusercontent.com/62828746/206799763-a6f440ad-869e-48a4-9b01-ff01c2ea4111.jpg)
*Review opt_check3.v file.*
![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations part2_1](https://user-images.githubusercontent.com/62828746/206799757-90d69bc5-476a-40ac-8832-f0ccc9cfb5e2.jpg)
*An 3-input AND gate was inferred in the circuit as expected*

  </details>
  

<details><summary> Lab06 Combinational Logic Optimisations (exercise) </summary>
  
#### Steps:
> 1. Review the two multiple_module verliog file (multiple_module*.v and multiple_module_opt2.v).
>> * *gvim multiple_module_opt.v -o multiple_module_opt2.v*
> 2. Run synthesis for multiple_module_opt.v and review it's netlist and grpahical block.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog multiple_module_opt.v*
>> * *synth -top multiple_module_opt*
>> * *flatten -> to get flat schematic*
>> * *opt_clean -purge-> command to do the optimization such as constant propagation*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*
> 3. Run synthesis for multiple_module_opt2.v and review it's netlist and grpahical block.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog multiple_module_opt2.v*
>> * *synth -top multiple_module_opt2*
>> * *flatten->to get flat schematic*
>> * *opt_clean -purge->command to do the optimization such as constant propagation*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations (exercise)_0](https://user-images.githubusercontent.com/62828746/206799866-4a387398-cdba-4283-916d-956567df71f0.jpg)

*Review multiple_module verliog file(multiple_module_opt.v and multiple_module_opt2.v)*

![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations (exercise)_1](https://user-images.githubusercontent.com/62828746/206799870-a47c7051-7b14-4041-a2c6-de493194b7a2.jpg)

*Synthesis result of multiple_module_opt.v*

![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations (exercise)_2](https://user-images.githubusercontent.com/62828746/206799872-3bb846d1-90c1-4ce2-966b-d51ab1131b7c.jpg)

*After flatten the hierachical and optimization, 3-input AND-OR gate is used for output Y.*

![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations (exercise)_3](https://user-images.githubusercontent.com/62828746/206799873-a6d92257-7ea8-46cf-8258-9ee41870dfa0.jpg)

*Synthesis result of multiple_module_opt2.v*

![SKY130RTL D3SK2 L2 Lab06 Combinational Logic Optimisations (exercise)_4](https://user-images.githubusercontent.com/62828746/206799874-21d36b85-c6d3-4561-a6f3-9b9b42651534.jpg)

*After flatten the hierachical and optimization, output Y is direct assigned to value 0*


  </details>
  
### :pencil2: Lab Topic - Sequential logic optimizations

<details><summary> Lab07 Sequential Logic Optimisations part1 </summary>
  
#### Steps:
> 1. Review the dff file that will be the example for sequential logic optimization.
>> *gvim dff_const1.v -o dff_const2.v*
> 2. Run simulation by apply RTL Design (dff_const1.v) and testbench (tb_dff_const1.v) as inputs.
>> *iverilog dff_const1.v tb_dff_const1.v*
>> *./a.out*
>> *gtkwave tb_dff_const1.vcd*
> 3. Run simulation by apply RTL Design (dff_const2.v) and testbench (tb_dff_const2.v) as inputs.
>> *iverilog dff_const2.v tb_dff_const2.v*
>> *./a.out*
>> *gtkwave tb_dff_const2.vcd*
> 4. Now, run synthesis for dff_const1 and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog dff_const1.v*
>> * *synth -top dff_const1*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib -> tell synthesis tool the sequential circuit is mainly for dff latches and only pick flip flop standard cell in .lib*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK3 L1 Lab07 Sequential Logic Optimisations part1_0](https://user-images.githubusercontent.com/62828746/206800029-a2a33821-33fb-405b-b6a0-46c461b81a47.jpg)
*Review dff verilog file.*
![SKY130RTL D3SK3 L1 Lab07 Sequential Logic Optimisations part1_1](https://user-images.githubusercontent.com/62828746/206800034-f72f23b8-16eb-4922-b9ad-ca7cf55e5068.jpg)
*Resulted waveform of tb_dff_const1.vcd*
![SKY130RTL D3SK3 L1 Lab07 Sequential Logic Optimisations part1_2](https://user-images.githubusercontent.com/62828746/206800036-48810996-470b-4ee5-b718-1a7044c4d45d.jpg)
*Resulted waveform of tb_dff_const2.vcd*
![SKY130RTL D3SK3 L1 Lab07 Sequential Logic Optimisations part1_3](https://user-images.githubusercontent.com/62828746/206800039-17e98ebf-6270-4ada-b961-64c6afa67456.jpg)
*Resulted graphic design is as expected.*

  </details>

<details><summary> Lab07 Sequential Logic Optimisations part2 </summary>
 
#### Steps:
> 1. Now, run synthesis for dff_const2 and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog dff_const2.v*
>> * *synth -top dff_const2*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib -> tell synthesis tool the sequential circuit is mainly for dff latches and only pick flip flop standard cell in .lib*
> 2. Review the dff_const3 verilog file that will be the next example for sequential logic optimization.
> *gvim dff_const3.v*

#### Result:
![SKY130RTL D3SK3 L2 Lab07 Sequential Logic Optimisations part2_0](https://user-images.githubusercontent.com/62828746/206800108-9b7dff16-df81-4d23-a506-649899d2830c.jpg)
*D flip flop are optmized in the constant propagation optimization steps.*
![SKY130RTL D3SK3 L2 Lab07 Sequential Logic Optimisations part2_1](https://user-images.githubusercontent.com/62828746/206800112-3efadaeb-489a-4c22-8f54-c8d227ee6007.jpg)
*Review dff_const3.v file.*

  </details>
  

<details><summary> Lab07 Sequential Logic Optimisations part3 </summary>

#### Steps:
> 1. Run simulation by apply RTL Design (dff_const3.v) and testbench (tb_dff_const3.v) as inputs.
> >> *iverilog dff_const3.v tb_dff_const3.v*
>> *./a.out*
>> *gtkwave tb_dff_const3.vcd*
> 2. Now, run synthesis for dff_const3 and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog dff_const3.v*
>> * *synth -top dff_const3*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib -> tell synthesis tool the sequential circuit is mainly for dff latches and only pick flip flop standard cell in .lib*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3_0](https://user-images.githubusercontent.com/62828746/206800170-a00e923d-05a9-4989-966d-f57417518e60.jpg)
*Resulted waveform of tb_dff_const3.vcd as expected.*
![SKY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3_1](https://user-images.githubusercontent.com/62828746/206800178-fcc2258f-c250-49f7-b411-62ec74abc160.jpg)
*There are 2 flip flop inferring in the circuit as expected.*
![SKY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3_2](https://user-images.githubusercontent.com/62828746/206800180-f9e39367-51a2-4fb0-a353-8922b87333fe.jpg)
*Resulted graphic design is as expected.*

  </details>

<details><summary> Lab07 Sequential Logic Optimisations part3 (exercise) </summary>

> 1. Review the dff file.
>> gvim dff_const4.v 
> 2. Run simulation by apply RTL Design (dff_const4.v) and testbench (tb_dff_const4.v) as inputs.
> >> *iverilog dff_const4.v tb_dff_const4.v*
>> *./a.out*
>> *gtkwave tb_dff_const4.vcd*
> 3. Now, run synthesis for dff_const4 and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog dff_const4.v*
>> * *synth -top dff_const4*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

> 1. Review the dff file.
>> gvim dff_const4.v 
> 2. Run simulation by apply RTL Design (dff_const5.v) and testbench (tb_dff_const5.v) as inputs.
> >> *iverilog dff_const5.v tb_dff_const5.v*
>> *./a.out*
>> *gtkwave tb_dff_const5.vcd*
> 3. Now, run synthesis for dff_const3 and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog dff_const5.v*
>> * *synth -top dff_const5*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![KY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)_0](https://user-images.githubusercontent.com/62828746/206800243-62f5e767-a4d0-416e-8712-704f4f7a7cff.jpg)
*Review dff_const4.v file.*
![KY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)_1](https://user-images.githubusercontent.com/62828746/206800246-e479b304-4b9c-4c1b-b298-5471625d0349.jpg)
*Resulted waveform of tb_dff_const4.vcd as expected, q1 and q value is constant.*
![KY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)_2](https://user-images.githubusercontent.com/62828746/206800251-1744bef1-c422-4fc4-8ca4-a0be846869b2.jpg)
*Resulted graphic design is as expected, flop,clk and reset are optimized.*
![KY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)_3](https://user-images.githubusercontent.com/62828746/206800253-1ad61fa2-5928-40ff-8665-93fd63e37e5b.jpg)
*Review dff_const5.v file.*
![KY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)_4](https://user-images.githubusercontent.com/62828746/206800256-990bf112-bc6f-49f3-a109-f574bb9384ec.jpg)
*Resulted waveform of tb_dff_const5.vcd as expected, q1 and q value is not constant.*
![KY130RTL D3SK3 L3 Lab07 Sequential Logic Optimisations part3 (exercise)_5](https://user-images.githubusercontent.com/62828746/206800261-6f33b73a-9113-4078-bd03-ad867d14e23e.jpg)
*Resulted graphic design is as expected, flop can't be optimized.*

  </details>

### :pencil2: Lab Topic - Sequential optimzations for unused outputs

<details><summary> Seq optimisation unused outputs part1 </summary>
  
#### Steps:
1. Review the counter_opt verilog and take it as example for optimisation of unused outputs in circuit.
>> * *gvim counter_opt.v*
> 2. Now, run synthesis and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog counter_opt.v*
>> * *synth -top counter_opt*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK4 L1 Seq optimisation unused outputs part1_0](https://user-images.githubusercontent.com/62828746/206800384-09212387-6ff5-48cd-808a-60629c718502.jpg)
*Review 3-bit counter, counter_opt.v file.*
![SKY130RTL D3SK4 L1 Seq optimisation unused outputs part1_2](https://user-images.githubusercontent.com/62828746/206800390-9ac3772b-da06-4ed1-b972-89673ced638a.jpg)
*Only one DFF used in circuit cause unused flop are optimized.*

  </details>
  
<details><summary> Seq optimisation unused outputs part2 </summary>
  
#### Steps:
1. Modidy counter_opt verilog and take it as second example for optimisation of unused outputs in circuit.
>> * *cp counter_opt.v counter_opt2.v*
>> * *gvim counter_opt2.v*
>> * *assign q = count[0] -> q = [count[2:0] == 3'b100]*
> 2. Now, run synthesis and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog counter_opt2.v*
>> * *synth -top counter_opt*
>> * *dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *show*

#### Result:
![SKY130RTL D3SK4 L1 Seq optimisation unused outputs part2_3](https://user-images.githubusercontent.com/62828746/206800449-e1829e70-88e6-44c1-bad0-d2947e56d408.jpg)
*Edit counter_opt2 verilog file and assigned q to counter[2] when bit 3'b100*
![SKY130RTL D3SK4 L1 Seq optimisation unused outputs part2_2](https://user-images.githubusercontent.com/62828746/206800447-c5125ee0-73ea-4b28-8ae2-9f15590eac50.jpg)
*There are 3 flops are inferred in the circuit as expected.*
![SKY130RTL D3SK4 L1 Seq optimisation unused outputs part2_1](https://user-images.githubusercontent.com/62828746/206800444-feda61e3-1b53-4474-9181-1d36abc56d6f.jpg)
![SKY130RTL D3SK4 L1 Seq optimisation unused outputs part2_0](https://user-images.githubusercontent.com/62828746/206800450-15bbd3b8-305a-4536-a644-d16c0c067b26.jpg)
*Highlighted path is the path of input to output path in summary.*

  </details>

## :bookmark: Day 4
### :bulb: Theory - GLS, blocking vs non-blocking and Synthesis-Simulation mismatch

<details><summary> Gate Level Simulation (GLS) </summary>
  
## **Gate Level Simulation (GLS):**
* **GLS** process also used to verify design's functionality but it includes standard cell/gate propagation delay into consideration in the verification process. And delays will change according to library used for synthesis.
* While **RTL simulation** process doesn't include standard cell/gate propagation delay into consideration while verify design's functionality.
* GLS used to verify dynamic circuit behaviour which can't be verified accurately by static methods.

  </details>

<details><summary> GLS using Iverilog Flow </summary>
  
## **GLS using Iverilog Flow:**
![GLS using Iverilog Flow](https://user-images.githubusercontent.com/62828746/206912462-bf416918-dbad-49f7-b07b-232ffbe067a4.jpg)
* It's similar with the simulation flow that using RTL code as DUT(design under test), just that now using **netlist as DUT**.
* Plus we have **gate-level verilog model** as inputs to simulator to define standard cell inside netlist to the tool.

  </details>

<details><summary> RTL Simulation vs Gate-level Simulation(GLS) </summary>
  
## **RTL Simulation vs Gate-level Simulation(GLS)**
Key   | RTL Simulation | Gate-level Simulation(GLS)
---| --------------------  | -------------------- 
**Function** | Simulates the code directly, it's a zero delay environment and intends only for functional check. | Simulate code using real timing, can be zero delay (functional only) but mostly with standard cell delays.
**Process** | Pre-synthesis | Post-synthesis
**Process Inputs** | RTL code (with functionality without timing information) | Compiled netlist (with/without timing information)
**Process Speed** | Fast (more simple since state of DUT updated once per clock cycle) | Very slow (more complex and event to calculate due to actual timing delays from layout)

  </details>
  
<details><summary> Gate Level Verilog Model </summary>

## **Gate Level Verilog Model:**
* **Gate-level modeling** involves gates and has a one to one relationship between a hardware schematic and the Verilog code.
* **Gate level verilog model** is used to define gate/standard cell inside the netlist.
+ **Type of gate level verilog model:**
  * **Timing aware:** ensure both design functionality and timing.
  * **Functional:** only ensure design functionality.

![Gate Level Verilog Model](https://user-images.githubusercontent.com/62828746/206912030-dc67e1f1-6d2b-4876-b097-8b16eb2f2c93.jpg)

  </details>

<details><summary> Sensitivity List </summary>
  
## **Sensitivity List**
* Simulators are event based. This means that simulators operate by taking events one at a time and propagating them through design until reached steady condition.

![Missing sensitivity list](https://user-images.githubusercontent.com/62828746/207013728-bb850dff-ceef-41f9-b5f6-e697ba1899f0.jpg)

* **Events:** Any transitions of input signals or always statement.
* **Sensitivity lists:** Used to indicate which events may trigger the process.
+ **Simulator:** 
  * will observe the sensitivity list. 
  * If an input of a procedure or always statement is not in the sensitivity list, a transition of that signal will not trigger the procedure, and no new output is produced.
+ **Synthesizer:**
  * will ignore the sensitivity list.
  * A new output is calculated according to the code of the procedure or always statement. 
  * May warn for an incomplete sensitivity list.
* Missing items in sensitivity list cause or hide a design flaw and cause **synthesis-simulation mismatch**.
 
  </details>

 
<details><summary> Blocking and Non-Blocking Statements in Verilog </summary>
  
 ## **Blocking and Non-Blocking Statements in Verilog:**

* **Blocking (=)** and **Non-blocking (<=)** assignments are provided to control the execution order within an always block.
* Coding styles (blocking and non-blocking assignment) in RTL code can cause mismatches between pre-synthesis (RTL Simulation) and post-synthesis (Gate-level Simulation) simulations. -> **Synthesis and simulation mismatch**

Blocking Assignments |  Non-Blocking Assignments
--------------------  | -------------------- 
Executes the statements in the order it is written | Executes all the RHS when always block is entered and assigns to LHS
Preserves logic flow, works better for combinational logic | Doesn't preserve logic flow, work better for sequential lofic
 
![BlockingAndNonBlockingStatementsInVerilog](https://user-images.githubusercontent.com/62828746/207052068-978ac909-5e02-42f7-8531-33c1cc1e7de7.jpg)

  </details>
  
### :pencil2: Lab Topic - Labs on GLS and Synthesis-Simulation Mismatch

<details><summary> Lab GLS Synth Sim Mismatch part1 </summary>

#### Steps:
> 1. Review the ternary operator mux file.
>> gvim ternary_operator_mux.v 
> 2. Run simulation by apply RTL Design (ternary_operator_mux.v) and testbench (tb_ternary_operator_mux.v) as inputs.
> >> *iverilog ternary_operator_mux.v tb_ternary_operator_mux.v*
>> *./a.out*
>> *gtkwave tb_ternary_operator_mux.vcd*
> 3. Now, run synthesis for ternary_operator_mux and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog ternary_operator_mux.v*
>> * *synth -top ternary_operator_mux*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *write_verilog -noattr ternary_operator_mux.v*
>> * *show*
4. Now run the GLS simulation for ternary operator mux using generated mux netlist.
>> *iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v ternary_operator_mux.v tb_ternary_operator_mux.v -> point to verilog model to find verilog model of the standard cell, library, verilog and testbench.
>> *./a.out*
>> *gtkwave tb_ternary_operator_mux.vcd*

#### Result:

![SKY130RTL D4SK2 L1 Lab GLS Synth Sim Mismatch part1_0](https://user-images.githubusercontent.com/62828746/207109722-5a504299-1f03-48a1-9c28-899f11e64afc.jpg)
*Review ternary operator mux verilog file.*
![SKY130RTL D4SK2 L1 Lab GLS Synth Sim Mismatch part1_1](https://user-images.githubusercontent.com/62828746/207109729-f81fb4e3-26d0-4b4a-a058-2a60e981fdda.jpg)
*Resulted waveform of ternary operator mux is as expected.*
![SKY130RTL D4SK2 L1 Lab GLS Synth Sim Mismatch part1_2](https://user-images.githubusercontent.com/62828746/207109713-4993db5a-9558-44df-98f5-6e89c790d6aa.jpg)
*Resulted circuit is as expected, infered with two cross one mux standard cell.*
![SKY130RTL D4SK2 L1 Lab GLS Synth Sim Mismatch part1_3](https://user-images.githubusercontent.com/62828746/207109719-7a84573f-9f2a-4ec7-8ccd-33ba2299f9d0.jpg)
*Resulted waveform as expected, GlS output follow mux behaviour.*
  
  </details>
  
<details><summary> Lab GLS Synth Sim Mismatch part2 </summary>
  
#### Steps:
> 1. Review the bad mux file.
>> gvim bad_mux.v 
> 2. Run simulation by apply RTL Design (bad_mux.v) and testbench (tb_bad_mux.v) as inputs.
> >> *iverilog bad_mux.v tb_bad_mux.v*
>> *./a.out*
>> *gtkwave tb_bad.vcd*
> 3. Now, run synthesis for bad_mux and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog bad_mux.v*
>> * *synth -top bad_mux*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *write_verilog -noattr bad_mux_net.v*
>> * *show*
4. Now run the GLS simulation for bad mux using generated bad mux netlist.
>> *iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v bad_mux.v tb_bad_mux_net.v -> point to verilog model to find verilog model of the standard cell, library, verilog and testbench.
>> *./a.out*
>> *gtkwave tb_bad.vcd*

#### Result:
![SKY130RTL D4SK2 L2 Lab GLS Synth Sim Mismatch part2_0](https://user-images.githubusercontent.com/62828746/207128208-7a8a738d-fd69-4d5e-886f-cd590e5648ca.jpg)
*Review bad mux verilog file.*
![SKY130RTL D4SK2 L2 Lab GLS Synth Sim Mismatch part2_1](https://user-images.githubusercontent.com/62828746/207128215-6175d4ff-970a-4531-ac81-18e8024a6454.jpg)
*Resulted RTL simulation waveform showing flop behaviour instead of mux.*
![SKY130RTL D4SK2 L2 Lab GLS Synth Sim Mismatch part2_2](https://user-images.githubusercontent.com/62828746/207128219-05d5ce3f-7d1f-4784-97dd-760b35edcdc2.jpg)
*Resulted gate-level simulation(GLS) waveform showing mux.*
![SKY130RTL D4SK2 L2 Lab GLS Synth Sim Mismatch part2_3](https://user-images.githubusercontent.com/62828746/207128224-7dd4bc3d-f108-4268-b54a-c2a28fb1fd2e.jpg)
*Comparison of RTL simulation and GLS waveform.*

  </details>
  
<details><summary> Lab Synth sim mismatch blocking statement part1 </summary>
  
#### Steps:
> 1. Review the blocking_caveat file.
>> *gvim blocking_caveat.v*
> 2. Run simulation by apply RTL Design (blocking_caveat.v) and testbench (tb_blocking_caveat.v) as inputs.
> >> *iverilog blocking_caveat.v tb_blocking_caveat.v*
>> *./a.out*
>> *gtkwave tb_blocking_caveat.vcd*
> 3. Now, run synthesis for blocking_caveat and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog blocking_caveat.v*
>> * *synth -top blocking_caveat*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *write_verilog -noattr blocking_caveat_net.v*
>> * *show*
4. Now run the GLS simulation for bad mux using generated bad mux netlist.
>> *iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v blocking_caveat_net.v tb_blocking_caveat.v -> point to verilog model to find verilog model of the standard cell, library, verilog and testbench.
>> *./a.out*
>> *gtkwave tb_blocking_caveat.vcd*


#### Result:
![SKY130RTL D4SK3 L1 Lab Synth sim mismatch blocking statement part1_0](https://user-images.githubusercontent.com/62828746/207128418-8408fbf0-aec3-49fd-ae66-fdc33c145cc1.jpg)
*Review blocking_caveat verilog file.*
![SKY130RTL D4SK3 L1 Lab Synth sim mismatch blocking statement part1_1](https://user-images.githubusercontent.com/62828746/207128420-a6e8c67e-d94a-4c7e-af2f-c52b385afc01.jpg)
*Resulted RTL simulation waveform shows that output depends on previous a value.*

  </details>

<details><summary> Lab Synth sim mismatch blocking statement part2 </summary>

#### Steps:
> 1. Now, run synthesis for blocking_caveat and review the result.
>> * *yosys*
>> * *read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *read_verilog blocking_caveat.v*
>> * *synth -top blocking_caveat*
>> * *abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
>> * *write_verilog -noattr blocking_caveat_net.v*
>> * *show*
2. Now run the GLS simulation for bad mux using generated bad mux netlist.
>> *iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v blocking_caveat_net.v tb_blocking_caveat.v -> point to verilog model to find verilog model of the standard cell, library, verilog and testbench.
>> *./a.out*
>> *gtkwave tb_blocking_caveat.vcd*


#### Result:
![SKY130RTL D4SK3 L2 Lab Synth sim mismatch blocking statement part2_0](https://user-images.githubusercontent.com/62828746/207128424-689b8d9c-8a16-41d4-b229-89e069235a1b.jpg)
*Resulted circuit is as expected, only include OR2AND Gate and no latch.*
![SKY130RTL D4SK3 L2 Lab Synth sim mismatch blocking statement part2_1](https://user-images.githubusercontent.com/62828746/207128427-cdec553e-5854-4e2c-a61c-4df7662fa1ae.jpg)
*Resulted gate-level simulation waveform shows expected result.*
![SKY130RTL D4SK3 L2 Lab Synth sim mismatch blocking statement part2_2](https://user-images.githubusercontent.com/62828746/207128431-44c8e7b2-01d9-4fdd-95ab-ab53476a7589.jpg)
*Comparison of RTL simulation and GLS waveform.*

  </details>


## :bookmark: Day 5
### :bulb: Theory - DFT (Design for Testability)
<details><summary> DFT (Design for Testability) </summary>

## **What is testability in VLSI means**
* Testability is the property of a circuit that makes it easy to test. If a design is well-controllable and well-observable, then it is easily testable.
* **Controllability** - ability to set a specific states or logic values (0 or 1) at each circuit nodes.
* **Observability** - ability to obeserve the states or logic values at any circuit nodes.

## **What is DFT (Design for Testability)**
* DFT is an innovative design technique which facilitates a design to become testable after production.
* DFT make testing a chip cost-effective by adding an extra logic/circuitry to the existing design.
* These extra design improve the observability and controability of internal nodes to increase testability of all logic in the design.
* Examples: addition of test points, parametric measurement devices, self-test diagnotics, test modes, and scan design.

## **Examples of circuit modifications or additions to make chip testable:**

Types | MBIST (Memory Built-In Self Test) | Scan Chains | Automates Test Pattern Generation (ATPG)
--------------------  | -------------------- | --------------------  | --------------------  |
Function | Running several algorithms and to verify memory functionality.It implements a finite state machine (FSM) to generate stimulus and analyze the response coming out of memories. | Inserted into designs to shift the test data into the chip and out of the chip. It was used by external automatic test equipment (ATE) to deliver test pattern data from its memory into the device. | It's the process of generating test patterns for a given fault model which will detect all possible fault conditions and find redundant circuit logic.   
Block diagram |![MBIST (Memory Built-In Self Test)](https://user-images.githubusercontent.com/62828746/207897281-cac40dd0-13d8-41a2-9dbc-9b510e47279f.jpg) | ![Scan Chains](https://user-images.githubusercontent.com/62828746/207914806-93cae819-50c7-4395-9a62-b1b266a26377.jpg) | ![Combinational Logic Testing](https://user-images.githubusercontent.com/62828746/207914814-c15beeda-166f-41e1-9048-663974c1efe1.jpg)
How it works | The MBIST controller provides control signals to the address and data generator. The memory, then, starts the BIST algorithms and provides the test output to the controller. The controller compares this output with the reference output and indicates if the MBIST has passed or failed.  | A multiplexer is added at the input of the flip-flop with one input of the multiplexer acting as the functional input D, while the other is Scan-In (SI). while scan-enable is used to control which input (D or SI) will propagate to the output. | To test an n input circuit is to generate all the possible 2N input signal combinations by means of say an N bit counter (controllability) and observe the outputs for checking (observability). But, is only practicable where N is relatively small.
Pros | * Allows robust testing of memories * Reduce in test cost and time * Design memories can be tested in parallel | Ensures that each circuit nodes becomes controllable and observable | * High fault coverage * Moderate area * Design automation
Cons | Increase in area |  * Extra I/O needed * Increse complexity and area  | * Large test data volume * Slow and long testing time
Used to test design | Macros/memory blocks | Flops | Cmbinational cirruit

## **Why do we need DFT**
* **DFT** makes testing easy at the post-production process.
+ DFT accomplishes two significant goals in the chip manufacturing process:
  * Control product quality by reject defective chips
  * Monitor and improve manufacturing process by identifying the probable defect location when testing various level.
+ 3 main levels of testing aftr chip being fabricated:
  * Chip-level, when chips are manufactured. Test overall product quality by ensure chip works smoothly.
  * Board-level, when chips are integrated on the boards/package. Test chips operationa life with temperature test.
  * System-level, when several boards are assembled together. To ensure that replaceable parts works smoothly.
*  Detect fault at earlier stage is important cause when move to higher levels, more components are integrated and it makes the fault detection and localization much more difficult and expensive.

**Pros** | **Cons**
---  | ---
Reduces tester complexity | Adds complication to the design flow.
Reduces tester time | Increase power, area, timing and package pins.
Reduces the chances of going into loss due to faulty devices | Design time increases

## **When DFT is included**
* DFT architecture is created at the beginning of design flow. Increase testability by adding extra blocks.
* DFT insertion occurs at synthesis stage during ASIC design flow. -> **Pre-fabrication**
* Dies are tested on wafer or re-tested with APTG patterns after passed wafer test. -> **Post fabrication**

## **Controllability in term of DFT**
* A point is said to be controllable if both ‘0’ and ‘1’ can be propagated through scan patterns.
* **Multiplexer (MUX)** are added into design to enable data selection (0 or 1) at every node which toggled by pattern inputs.
![Controllability](https://user-images.githubusercontent.com/62828746/207980453-957561a6-239d-4e00-a2e0-9869c81271e2.jpg)


## **Observability in term of DFT**
* A node is observable, when the value at the node can be shifted out through scan patterns and can be observed through scan out ports. 
* Flip-flops are added into design to store data and enable changes in output corresponding to the toggling of a node obsevable at packaged pins.
![Observability](https://user-images.githubusercontent.com/62828746/207980443-51eac9cb-5c90-46d5-a5f7-0379bb2f9c1c.jpg)


## **DFT techniques are mainly classified into two types:**
+ **Ad-hoc techniques:** collection of techniques or set of rules in the chip design process learned from design experience to improve/accomplish design testability.
  * Avoid combinational feedback.
  * All flip flops must be initializable.
  * Partition a large circuit into small blocks.
  * Provide test control for the signals which are notcontrollable.
  * While designing test logic we have to consider theATE requirements.

+ **Structured techniques:** extra logic and signals are added to the circuit to allow the test according to some predefined procedure.
  * Scan: In the design all the flip flops are converted to scan flip flop.
  * Boundary Scan
  * Built-in self-test (MBist & LBist)

## **Scan based technique/ Scan-chains**
![Scan-chains](https://user-images.githubusercontent.com/62828746/207972544-9efebac7-6830-4e2f-b73c-9e1586507d2e.jpg)
*[Reference:Overview and Dynamics of Scan Chain Testing](https://anysilicon.com/overview-and-dynamics-of-scan-testing/)
* Scan chains are the elements in scan-based designs that are used to shift-in and shift-out test data. 
* Scan chains: scan flip-flops are connected together in form of a chain.
* Scan flops: normal input (D) of the flip-flop are multiplexed with the scan input. Scan-enable signal is used to control which input will propagate to the output.
* When scan_enable port = 0 : data at D pin of the flop will propagate to Q at the next active edge.
* When scan_enable port = 1 : data present at scan-in input will propagate to Q at the next active edge.
+ Purpose of scan flops:
  * To test stuck-at faults in manufactured devices.
  * To test the paths in the manufactured devices for delay. (to test whether each path is working at functional frequency or not)

![Waveform without fault](https://user-images.githubusercontent.com/62828746/207972548-b3ed8eff-8bc8-4279-86d9-a6a4cdba4c7e.jpg)

+ Scan chain operation involves three stages:
  * Scan-in/Assert scan_enable: test patterns are loaded keeping the design in test timing mode.
  * Scan-capture: design is kept in functional timing mode and test pattern response is captured.
  * Scan-out/De-assert scan_enable: design is brought back in test timing mode and test pattern response is unloaded.

## **Functionality of scan-chain**
* Scan chains is to make each node in the circuit controllable and observable through limited number of patterns by providing a bypass path to each flip-flop.
* Scan chain is slightly different for slow capture (**Stuck-At faults**) and at speed capture (**Path Delay or Transition faults**).

**Scan-in**
* 1.SE is kept high (asserted) enables the scan mode and scan flip flop take SI value as inputs.
* 2.Test patterns will serially enter from the scan input port and enter first flip-flop of the scan chain.
* 3.At each active clock edge, it will shift to the next stage of flip-flop (shift register behaviour).
* 4.All scan chain elements will be loaded with the correct test patterns. 

![Stuck-At faults](https://user-images.githubusercontent.com/62828746/207972546-4f2ef6a3-334b-40d4-a87b-1106c588e818.jpg)

**Capture of stuck-at Testing**
*done at a slower frequency hence one pulse of clock*
* 1.SE is de-asserted, flip-flops works in normal functional timing mode and the test pattern response processed by the combinational logic is captured at the next stage of the flip-flop.
* 2.Before arrival of next active clock edge, the test pattern response is processed by the combinational logic and becomes available at the D input of next flip-flop.
* 3.At next positive clock edge, the processed test pattern response is captured by the next flip-flop and becomes available at the Q and SO pin.

![Path Delay or Transition faults](https://user-images.githubusercontent.com/62828746/207972535-7f8d92b8-0439-4e33-872f-4044be503c83.jpg)

**Captureof Speed-Transition/Path delay Testing**
*Testing is done at functional speed therefore the design is put in the function timing mode at functional frequency.* 
*This will require two or more functional clock pulses in the capture mode.*
* 1.SE is de-asserted, flip-flops works in normal functional timing mode.
* 2.Test pattern data is launched from D to Q pin of the flop at first capture pulse.
* 3.Test pattern data is captured by the next flip flop at second capture pulse, reached Q pins and SO pin of the subsequent flip-flop in the scan chain.
* 4.First clock pulse is launching the test pattern to the targeted combinational logic and second clock pulse ensures that combinational logic is getting at speed processing time.

**Scan-out**
* 1.SE is re-asserted in this mode, design is back to test timing mode.
* 2.At posedge clock edge, the captured data (test pattern response processed by the combinational logic) is serially shifted out on the scan chain.
* 3.Test pattern response captured at the SI pins of the flip-flops and was shifted serially out to the scan output port.
* 4.Compare output value with expected result.

## **Automated test equipment (ATE)**
* Automated test equipment (ATE) is a testing apparatus designed to perform a single test or sequence of tests on one or multiple devices at a time.
* The main goal of ATE is to ensure that an electronic device works as intended.
* The raw data captured by the test instruments is monitored, analyzed, and stored using the master controller’s signal sources and test software. Output readings are used to determine whether changes to the device need to be made or it's ready to be go.
* ATE frequently used by semiconductor manufacturers to test microprocessors, memory chips and analog integrated circuits.

**Basic automate testing system**

![Basic Automated Test System](https://user-images.githubusercontent.com/62828746/207969107-474e4002-e9ad-44b5-8d43-79cea19f357a.jpg)

* **Test controller:** implements test coding which runs the test system. 
* **Testing devices and testing instruments:** offer power and testing signals to the unit under testing and calculating the operation features of the module over the testing.
* **Test fixtures:** interlinks to the automated testing network to the UUT or unit under test.
* **Switching controller:** defines instructions from the test controller to manage the switching circuits that interlinks the testing device and test instrument with the certain testing points at the UUT.
* **Switching circuitry:** interlinks the testing devices and testing modules to certain positions known as the testing point at the module over which the test is done.
* **UUT:** can be one element, circuitry board or hole electronics packaging.

**Basic ATE functionality**
* 1. Scan-In Phase: control flip-flop operation in the serial shift state by scan enable signals
* 2. Parallel Measure: scan enable is invalid, and circuit working is in normal condition. Send basic input signal (primary input) from the input port of circuit this moment, and do not produce clock pulse, thereby trigger output constant.
* 3. Parallel Capture: circuit still is operated under the normal condition.ATE produces a clock pulse at this moment, and the virtual basic output signal of the D end of the trigger that previous step is produced captures the Q end of trigger.
* 4. First Scan-Out Phase: scan enable signals is effective, and flip-flop operation is in serial output mode, but ATE does not produce clock pulse.
* 5. Scan-Out Phase: circuit working is in serial output mode, after producing N clock, just obtain the total data of virtual basic output signal from SO port, squeeze into next test and excitation vector (test signal) from SI port simultaneously.

*[Reference:Method for increasing tested failure coverage of circuit](https://patents.google.com/patent/CN1381878A/en)


## **How DFT can be game changer for VLSI engineers**
* VLSI chips are reducing size and thickness day to day. Reduced in chip size with large number of transistor inside cause chip density increased. High chance this will casue issues during chip design flow. 
* DFT can help to check whether it's designed and working in expected way in early stage, which can help to reduce cost and time delay compared to finding bugs in post-fabrication stage.
* Faulty chips can cause huge loss to company hence DFT is important for improving chips quality that are being sold in the market.

  </details>

  
## :bookmark: Day 6
### :bulb: Theory - Introduction to Logic Synthesis

<details><summary> Digital logic </summary>
  
## **Digital logic**
* **Switching function:** voltage level in digital logic circuit are assumed to be switching from one value to another value instantaneously.
* **Automation and decision making:** logic gate perform logic operation which conduct logic decisions and the output depends on preset conditions.
* Behavioral model of the design are written in HDL (VHDL and Verilog).
 
  </details>

<details><summary> What is logic synthesis </summary>
 
## **What is logic synthesis**
![What is logic synthesis](https://user-images.githubusercontent.com/62828746/208393821-1aac68f0-79e0-4fff-adf4-bb8fb02ae5a2.jpg)

* Synthesis is a process of converting RTL into gate level translation
* Logic synthesis is combining primitive logic functions to form a design netlist that meets functional and design goals.
* Basic steps (Translation > Logic optimization > Gate level mapping)
* Synthesis output: Gate-level netlist
 
  </details>
  
<details><summary>Constraints (.sdc)</summary>
 
## **Constraints (.sdc)**
* Constraint is a set of rule that set limit on circuit parameters according to parameter priorities and requirements (in term of functional, timing, area and power). 
* Optmization steps in synthesis is constraint driven. 

   </details>

<details><summary> Standard cell library (.lib) </summary>
  
## **Standard cell library (.lib)**
* Designer need to set priority design constraints and synthesis tool will choose **combinational library cells from .lib** that met design's requirement. 
* .lib consists of various basic gates with different flavours.
 
   </details>
   
   
<details><summary> Why we need different flavours of gate? </summary>
 
### **Why we need different flavours of gate?**
As per mentioned in previous session, flavours of gate will effect ciruit operation speed:
[How Flavours of Gate Effect Ciruit Operation Speed](https://github.com/teoh5128/intel-sd-training#how-flavours-of-gate-effect-ciruit-operation-speed)

![Why we need different flavours of gate](https://user-images.githubusercontent.com/62828746/208393825-2536b926-9624-42dc-bdab-5c4e31c8e7c5.jpg)

* Comninational delay (TCOMBI) in logic path determines speed of operation of digtial logic circuit (FCLK).
* Different flavours of gates in .lib help synthesis tool to choose combinational cells that mets delay requirement (TCOMBI).
* Not only fast cells we also need slow cells.
 
   </details>
   
<details><summary> Why we need slow cells? </summary>
 
### **Why we need slow cells?**

![Why we need slow cells](https://user-images.githubusercontent.com/62828746/208393829-d7ad1eec-ac76-4a27-911d-0d24483c3fbe.jpg)

* **Setup time:** amount of time the data at the synchronous input (D) must be stable before the active edge of clock
* **Hold time:** amount of time the data at the synchronous input (D) must be stable after the active edge of clock.
* **Hold time violation:** ouput data from previous cycle (DFFA) reach next flip flop input too early causing new data might not correctly stored in flip-flop (DFFB).
* To ensure there's no **hold issues**, we need cells that work slowly.
* This is why we need cells in different flavours, fast cell to meet performance and slow cell to meet hold.

   </details>
   
<details><summary> Trade Off of Fast Cell and Slow Cell </summary>
 
## **Trade Off of Fast Cell and Slow Cell**
**Key**              | **Fast Cell**                                   | **Slow Cell**
------------------   | ---------------------------------------------   | --------------------------------------------- 
Capacitance | Faster charge/discharge | Slower charge/discharge
Transistor | Wider, capable sourcing more current | narrow, not capable sourcing more current
Delay | Lower | Higher
Area used | Higher | Lesser
Power used | Higher | Lesser
Used for | High frequency circuit | Meet hold time

  </details>

<details><summary> Comparison of implementation </summary>
 
## **Comparison of implementation**

![Comparison of implementation](https://user-images.githubusercontent.com/62828746/208427485-dd5a074e-8152-4885-a529-bb2e8987200a.jpg)

* Different logic circuit implementation results in different area and delay value.
* There can have various type of combinational logic gates to implement Boolean function.
* Based on the 3 type of implementation above, type 3 which use lower area and delay might be the best choice.
* But if logic is present in **hold sensitive path**, an **additional delay buffers** are required to meet hold. These will result in additional area.


* **In shorts, different cell flavour and logic implementation are required to meet different design specification.**

     </details>
   
<details><summary> Goals of synthesis </summary>
 
## **Goals of synthesis**
+ To get a Gate-level netlist which is:
  * **Logically correct** - Logic equivalence between RTL and netlist, logic optimization
  * **Electrically correct** - Inserting DFT logic
  * **Met timing** - Inserting clock gates
 
     </details>
     
## :bulb: Theory - Introduction to Design Compiler (DC)

<details><summary> Design Compiler (DC) </summary>
 
## **Design Compiler (DC)**
![Design Compiler (DC)](https://user-images.githubusercontent.com/62828746/208424612-dab6abb8-488c-42b3-a47e-7e84db1b3ac3.jpg)

* DC is the core synthesis engine of Synopsys synthesis product family.
* Used for logic synthesis which convert design description (written in Verilog or VHDL) into optimized gate-level netlist mapped to specific technology library.
+ 4 basic steps for synthesizing a design: 
  * Analyze & Elaborate
  * Apply Constraints
  * Optimization & Compilation
  * Inspection of Results
 
     </details>
     
<details><summary> Common terminologies associated with DC </summary>
 
## **Common terminologies associated with DC:**
+ **SDC (Synopsys Design Constraints)**
  * Industry standard and suppoted by different EDA (Electronic Design Automation) tools implementation tools.
  * From Synopsys but can be understood by other EDA tools such as Cadence and Mentor Graphic.
  * As guidance for Synopsys tool to pick what flavours of cell and optimization type to achieve best implementation result.
  * Design intent in terms of timing, area and power constraints.
  * SDC is based on TCL. (Tool Command Language)

+ **.LIB**
  * Design library which contains collection of standard cells in various flavour. 
  * But cannot understand by DC, need to be converted to .db.

+ **.DB**
  * Same as .lib but in different format.
  * Can be understand by DC.

+ **DDC**
  * Synopsys proprietary format for storing design information.
  * It's a binary file which contains both verilog gate level description and design constrains.
  * DC can write out and read in DDC.

+ **Design**: RTL files which contains behavioral model of design.

  </details>
    
<details><summary> Implementation Flow of ASIC (Application Specific Integrated Circuit) </summary>
 
## **Implementation Flow of ASIC (Application Specific Integrated Circuit)**
![Implementation Flow of ASIC](https://user-images.githubusercontent.com/62828746/208424595-112999c9-f5f9-4092-a276-556a4ec89aa8.jpg)
* ASIC design flow adopted by engineers for efficient structured ASIC chip architecture and focus on its design functionalities.
* It's a steps in converting RTL to the Physical Database (GDS).
* Synthesized netlist, design constraints and standard cell library are taken as inputs and converted to a layout (gds file).
+ Difference of ASIC and SoC (System On Chip):
  * ASIC - chips basically hardwired to do a specific task. Not applicable for general-purpose task.
  * Soc - collection of different type of processor components (ex: CPU/Modems and memory units).
 
  </details>

<details><summary> DC Synthesis Flow </summary>
 
## **DC Synthesis Flow**
![DC Synthesis Flow](https://user-images.githubusercontent.com/62828746/208424605-590f8d17-f5e9-4b98-9db3-3ed2caab180e.jpg)
* Synthesis is a **process of converting RTL into a technology specific Gate level netlist** which includes nets, sequential cells, combinational cells and their connectivity.
+ There are 2 types of synthesis:
  * **Logical synthesis:** convert RDT to Gate level netlist. Includes gate mapping and optimization (timing/area/power) steps.
  * **Physical synthesis:** transform Gate level netlist to a layout that can be implemented on silicon. Includes floorplanning, placement, routing, clock tree synthesis and multiple different steps of local and global optimizations.

  </details>

### :bulb: Theory - TCL quick refresher

<details><summary> Basic TCL Command Used in DC </summary>

## **Basic TCL Command Used in DC**
**TCL command**      | **Function**                                   | **Example**
------------------   | ---------------------------------------------   | --------------------------------------------- 
set | to create and store information in variabels | *set a 5* -> assigned a = 5  <br />  *set a [expr $a + $b]* -> assign a = a + b  <br /> #square bracket used for nesting command
if loop | If Boolean expression evaluates true, then if block of code will be executed, otherwise else block of code will be executed. | Syntax and example code of an 'if...else' statement <br /> ![if_loop](https://user-images.githubusercontent.com/62828746/208475719-a58e6e77-2bb6-42a8-b852-d0292f0c44b4.jpg)
while loop | It evaluates test as an expression. If test is true, the code in body is executed. After the code in body has been executed, testis evaluated again. |  Syntax and example code of an 'while' statement <br /> ![while_loop](https://user-images.githubusercontent.com/62828746/208477034-f76b3762-6afe-4d0f-b74d-10383710bb0e.jpg)
for loop | A repetition control structure that allows code written to be executed for a specific number of times. |  Syntax and example code of an 'for' statement <br /> ![for_loop](https://user-images.githubusercontent.com/62828746/208478176-f27a59ad-a641-476d-8801-7ab3058f0e22.jpg)
foreach | Implements a loop where the loop variable(s) take on values from one or more lists. | Syntax and example code of an 'foreach' statement <br /> ![foreach_loop](https://user-images.githubusercontent.com/62828746/208479912-f4dfe426-5f30-4813-a871-05bdd0889f05.jpg)
foreach_in_collection | Similar to the foreach, just it was used to iterate through all elements in a collection instead of lists | Syntax and example code of an 'foreach_in_collections' statement <br /> ![foreach_in_collection](https://user-images.githubusercontent.com/62828746/208481531-8230cf9d-8fe9-49f6-ae6c-319014223ac2.jpg)

  </details>
        
### :pencil2: Lab Topic - Introduction to Logic Synthesis

<details><summary> Lab1 - Invoking dc basic setup </summary>

#### Steps:
> 1. Go to home directory, create a folder for sd_training.
>> cd /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/
>> mkdir sd_training
> 2. Clone directory "sky130RTLDesignAndSynthesisWorkshop" from Kunal's github.
>> *git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git*
> 3. Explore copied directory and confirm there's all the required folders and files.
>> *cd sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP*
> 4. Goto lib/ and make sure "sky130_fd_sc_hd__tt_025C_1v80.db" lib is inside.
>> *cd lib/*
> 5. Goto verilog_files which stored all the verilog and testbench fill that will be used in subsequent labs.
>> *cd verilog_files/*

 #### Result:
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_0](https://user-images.githubusercontent.com/62828746/208451379-0fcfde28-271c-4278-a89a-d18c5ab68f3b.jpg)
 
 #### Steps:
> 1. Open library file and review what contains in .lib file. [*DO NOT EDIT .LIB FILE, ONLY READ]
>> *vim /lib/sky130_fd_sc_hd__tt_025C_1v80.lib*
> 2. Tips to switch off syntax for more pleasant review experience. 
>> *:syn off*
> 3. Look into the information contains in .lib, such as library name, power, voltage and temperature of cell.
 
 #### Result:
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_1](https://user-images.githubusercontent.com/62828746/208451395-8f487a2b-646c-47eb-ae52-3665aa99667e.jpg)

 
 #### Steps:
> 1. Invoke dc 
>> csh -> to enable c shell
>> dc_shell -> invoke dc compiler
> 2. Read verilog file using command.
>> *read_verilog DC_WORKSHOP/verilog_files/lab1_flop_with_en.v*
> 3. Write verilog 
>> *write -f verilog -out lab1_net.v*
> 4. Read db and point to to correct path so that fix can't link library issues.
>> *read_db DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db*
>> *set target_library /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db*
>> *set link_library {* /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db}*
>> *link*
> 5. Compile the design
>> *compile*
> 6. Now, write verilog again which should be using cell inside sky130_fd_sc_hd__tt_025C_1v80.db.
>> *write -f verilog -out lab1_net_with_sky130.v*
> 7. Write in ddc format
>> *write -f ddc -out lab1.ddc*

#### Result:
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_2](https://user-images.githubusercontent.com/62828746/208451398-4d509a34-d1dd-4996-a25a-6c702838f490.jpg)
*Invoke dc shell and read_verilog*
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_3](https://user-images.githubusercontent.com/62828746/208451403-93f3248c-045f-435d-b84d-0b992d124cd5.jpg)
*Read verilog file lab1_flop_with_en.v*
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_4](https://user-images.githubusercontent.com/62828746/208451406-3d69a653-ae30-4c2d-8db0-5dd44c35e05f.jpg)
*Review written verilog file which used GTECH library.*
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_5](https://user-images.githubusercontent.com/62828746/208451413-7f58fe6b-2aa3-4e6c-a1bf-665143e05b28.jpg)
*Read db and point to to correct path*
![DC_D1SK2_L1 - lab1 - Invoking dc basic setup_6](https://user-images.githubusercontent.com/62828746/208451416-36ab88a9-476e-4ae2-8d3d-854264d63fce.jpg)
*Review written verilog file which used correct library path sky130_fd_sc_hd__tt_025C_1v80.db*
 
   </details>
   
<details><summary> Lab2 - Intro to ddc gui with design_vision </summary>

#### Steps:
> 1. Launch design vision
>> *csh*
>> *design_vision*
> 2. In invoked design vision gui, use command to read ddc file.
>> *read_ddc lab1.ddc*
> 3. In logical hierarchy bar, right click and choose schematic view, double click the schematic moduel to see detail connection.

#### Result:
![DC_D1SK2_L2 - lab2 - Intro to ddc gui with design_vision_0](https://user-images.githubusercontent.com/62828746/208464654-bb84b2d8-d431-444e-b9fe-77b66e9eff7b.jpg)
*In invoked design vision gui, use command to read ddc file.*
![DC_D1SK2_L2 - lab2 - Intro to ddc gui with design_vision_1](https://user-images.githubusercontent.com/62828746/208464660-e81cc44b-4c9b-4903-95c2-6a88f668a44a.jpg)
*Comparison of read_verilog and read_ddc in design vison gui.*
![DC_D1SK2_L2 - lab2 - Intro to ddc gui with design_vision_2](https://user-images.githubusercontent.com/62828746/208464662-900e1049-c0b1-4d6f-beba-93d7f801a234.jpg)
*Schematic view of design lab1_flop_with_en.v*
![DC_D1SK2_L2 - lab2 - Intro to ddc gui with design_vision_3](https://user-images.githubusercontent.com/62828746/208464665-df404f0b-4db1-4300-9ba5-4d265cba0e70.jpg)
*Resulted schematic view is as expected.*
 
   </details>
   
   
   
<details><summary> Lab3 - dc synopsys dc setup </summary>

#### Steps:
> 1. Invoke dc 
>> *csh* 
>> *dc_shell* 
> 2. To avoid tool using dummy library as default, set target library and link library everytime invoke dc.
>> *set target_library /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db*
>> *set link_library {* /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db}*
> 3. To avoid set multiple db files for design (which is troublesome and error prone) each time invoke dc, use command to replace installed default synopsys dc setup with home directory's synopsys dc setup. Then, all repetitive task (mainly target library and link library) which is needed for tool setup can be pointer in this file.
>> *cd <home directory>*
>> *gvim .synopsys_dc.setup*
> 4. Edit .synopsys_dc.setup file
>> set target_library /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/sky130_fd_sc_hd__tt_025C_1v80.db*
>> set link_library {* $target_library}
>> :qa! -> save file
> 5. Invoke dc shell again, will see target and link library auto set to sky130_fd_sc_hd__tt_025C_1v80.db.
>> csh
>> dc_shell
 
#### Result:
![DC_D1SK2_L3 - lab3 - dc synopsys dc setup_0](https://user-images.githubusercontent.com/62828746/208471728-ca45600d-2560-4ae8-8974-5e511612d00f.jpg)
*Invoke dc shell and manually set library path*
![DC_D1SK2_L3 - lab3 - dc synopsys dc setup_1](https://user-images.githubusercontent.com/62828746/208471736-f8ec2aa1-93a2-41e0-bbb7-4f2ef10daea5.jpg)
*Invoke dc shell after replace installed default synopsys dc setup with edited home directory's synopsys dc setup*

 </details>

<details><summary> Lab4 - tcl scripting </summary>
 
#### Result:
![DC_D1SK3_L2 - lab4 - tcl scripting_0](https://user-images.githubusercontent.com/62828746/208494512-805be48a-d90b-4702-90f5-3b76c3842b0c.jpg)
 *Example of for loop and mistake in syntax.*
![DC_D1SK3_L2 - lab4 - tcl scripting_1](https://user-images.githubusercontent.com/62828746/208494518-bf5a0e2e-9380-4b3c-8e00-3969ae81855b.jpg)
 *Example of while loop and mistake in syntax.*
![DC_D1SK3_L2 - lab4 - tcl scripting_2](https://user-images.githubusercontent.com/62828746/208494522-21be38eb-6c4d-4e9b-87f6-bb1ee9cd6032.jpg)
 *Example of foreach loop and mistake in syntax.*
![DC_D1SK3_L2 - lab4 - tcl scripting_3](https://user-images.githubusercontent.com/62828746/208494525-aa6172c7-98f8-4c24-bb02-125a02aa2c2a.jpg)
 *Example of foreach_in_collection loop and mistake in syntax.*
![DC_D1SK3_L2 - lab4 - tcl scripting_4](https://user-images.githubusercontent.com/62828746/208494529-02a7836a-de9e-423a-b057-7837a821ec54.jpg)
 *Example of exprresion syntax.*
![DC_D1SK3_L2 - lab4 - tcl scripting_5](https://user-images.githubusercontent.com/62828746/208494532-b8add567-b350-4e20-a7cb-a4dfda8a2a9f.jpg)
 *Example of print list use and no use foreach loop.*

 </details>


 
  
## :bookmark: Day 7 
### :bulb: Theory - Introduction to STA


<details ><summary> Introduction to STA </summary>
 
## **Introduction to STA**
* **What is STA?:**
<br /> STA will adding net delays and cell delays to obtain path delays. Then, STA tool will analyze all paths from each start point to each end point, compare it against timing constraints set for the path and make sure it met the timing spec of design.
 
+ **Why we need STA?:**
  * STA helps to calculate path delay for optimization tool and help the tool to chose most optimcal cell from .lib to create a circuit that met timing constraints. 
  * STA helps to verify circuit working at specified frequency.

* **When will STA included in design flow?**
 <br /> STA is covered during Synthesis stage in ASIC design flow. To check whether design spec meet timing requirement without simulation.

![Delay](https://user-images.githubusercontent.com/62828746/209027821-346ad7d6-004d-44c4-92bc-74b95fc2fb0e.jpg)
 
+ Delay of a cell will be a function of **Input Transition** (Inflow)
  * Delay is function of current
  * Fast current/fast input: less delay/fast rise

+ Delay of a cell will be a function of output load 
  * Delay is function of load capacitance
  * Larger load: higher delay/slower transition time
 
 
![Timing arc](https://user-images.githubusercontent.com/62828746/209027829-dcb6dcd7-06eb-42ee-8c8a-05bedb9066f6.jpg)

* Timing arc: represents the timing relationship between 2 pins of any cell or block or any boundaries. And it defines the propogation of signal through logic gates.
* Basically it has a start point and end point.
+ Delay for sequential cell:
  * Delay from Clock to Q for D Flip Flop
  * Delay from Clock to Q, Delay from D to Q for D Latch
  * Setup and Hold time delay
 
* D to Q delay only happened for D latch.
* D latch sampling point start at where the D latch become opaque.

 
   </details>
 
### :bulb: Theory - What are constraints?
<details><summary> What are constraints </summary>

![timing path](https://user-images.githubusercontent.com/62828746/209027830-ee44f46c-5e6a-4809-900b-2a05dc6af6ff.jpg)

* **Critical path:** Path that deciding or limiting clock frequency
* Timing path 1 and 2 has different Tcombi delay, where timing path 1 that has higher delay become the critical path.
* Set a clock period value and synthesis will choose cells that meets the delay (Tcombi delay) -> constraint to design

 
![Constraints summary](https://user-images.githubusercontent.com/62828746/209027816-7b3625cb-922a-44fb-8c2c-1d24d6dd4d40.jpg)

+ Timing path always start at one start point and end at one of the end points
  * CLK to D - start:clock pins of register, end:D pins of DFF/D-Latch
  * Clk to Output - start:clock pins of register, end:output port
  * Input to D - start:input port, end:D pins of DFF/D-Latch
  * Input to Output - start:input port, end:output port
* inA/InB/OutY: interface at the boundary of whole chip (module)
+ Type of timing paths:
  * Reg2Reg: constrained by clock (eg: CLK to D)
  * Reg2Out: constrained by output external delay and clock perios ( IO path, eg: Clk to Output)
  * In2Reg:  constrained by internal external delay and clock perios ( IO path, eg: Input to D)
* IO Delay Modelling: Delay modelling that referred IO timing path and IO budgeting is based on the interaction with other modules outside the module bundary.

 
   </details>
 
### :bulb: Theory - Inp Trans Output Load
<details><summary> Inp Trans Output Load </summary>

![Model transition delay](https://user-images.githubusercontent.com/62828746/209027827-0052c41e-f37b-4453-913e-3d416a4723a6.jpg)

* For ideal case, transition delay is not counted in and this might cause input logic delay will increased (due to add in trans delay).
* This will cause setup time for next capturing flip flop violated.
* Hence, we need to model input transition delay to avoid setup violation for next capturing DFF.
* Specification of design will tell the tools how much should the delay (transition and load) be modelled, depends on the distance with other module.
* It should be optimally and correctly modelled cause over modelling of delay will give negative returns which is not looking forward to.

![Model output load delay](https://user-images.githubusercontent.com/62828746/209027824-007ca258-ef77-4ff5-a279-49c91e1beaac.jpg)

* For ideal case, ouput load delay is not counted in and this might cause output logic delay will increased (due to add in output load delay).
* This will cause setup time for next capturing flip flop violated.
* Hence, we also need to model output load delay to avoid setup violation for next capturing DFF.
* Always remember: **delay of cell is the function of Input Transition and Output Load.**
 
   </details>



### :pencil2: Lab Topic - Basics of STA

<details><summary> Lab5 - Timing dot Libs </summary>

#### Steps:
> 1.Open .lib file and review the information.
>> *gvim sky130_fd_sc_hd__tt_025C_1v80.lib*

 #### Result:
![DC_D2SK2_L1 - Lab5 - Timing dot Libs_0](https://user-images.githubusercontent.com/62828746/209026589-fb54710e-dd1f-44ad-b153-4f120f6920f4.jpg) 

 *Review delay model and default maximum transition inside .lib*
 
![DC_D2SK2_L1 - Lab5 - Timing dot Libs_1](https://user-images.githubusercontent.com/62828746/209026593-a557f509-bdd4-48d1-a584-521292fa4b67.jpg) 

 *More input driver, area higher, transistor wider and delay lower.*
 
![DC_D2SK2_L1 - Lab5 - Timing dot Libs_2](https://user-images.githubusercontent.com/62828746/209026595-1c81d70b-fce3-485e-b2b3-9d9d664b01b5.jpg) 

*Review other cell pin's attribute inside .lib*
 
![DC_D2SK2_L1 - Lab5 - Timing dot Libs_3](https://user-images.githubusercontent.com/62828746/209026597-59260329-4fdc-4e90-b2ea-ef3214f00597.jpg) 
 
*Effect of area of cell and load capacitance to delay of cell*
 
![DC_D2SK2_L1 - Lab5 - Timing dot Libs_4](https://user-images.githubusercontent.com/62828746/209026598-d5e51bbd-014d-4782-811e-ee7103bc4004.jpg) 
 
*Tools use unateness to propogate the transition of cell.*
 
![DC_D2SK2_L1 - Lab5 - Timing dot Libs_5](https://user-images.githubusercontent.com/62828746/209026600-d2d63b73-669c-41e6-81bc-3e1692a3cd73.jpg) 
 
*Example of Unatness for various cells*
 
   </details>
   
   

<details><summary> Lab6 - Exploring dotLib </summary>
 
#### Steps:
> 1.Open .lib file and review the information.
>> *gvim sky130_fd_sc_hd__tt_025C_1v80.lib*
> 2. Load dc shell to get sequential library cell name
>> csh
>> dc_shell
>> *get_lib_cells */* -filter "is_sequential==true"*
 
#### Result:
![DC_D2SK2_L2 - Lab6 - Exploring dotLib_0](https://user-images.githubusercontent.com/62828746/209026602-f8741a38-64ad-4c97-84ae-20d816d45974.jpg)

 *Attribute/constraints set for DFF*
 
![DC_D2SK2_L2 - Lab6 - Exploring dotLib_1](https://user-images.githubusercontent.com/62828746/209026604-efd93363-6678-406c-86b0-bee20044c543.jpg)

 *Timing type for posedge DFF (dlrtp) and negedge DFF (dlrtn)*
 
   </details>
   
   
<details><summary> Lab7 - Exploring - dotLib part2 </summary>
 
#### Steps:
>1.List what library has linked
>> *list_lib*
>2.Sort out all "AND" cell name inside library
 
`foreach_in_collection my_lib_cell [get_lib_cells */*and*] {                                                                        
set my_lib_cell_name [get_object_name $my_lib_cell];
echo $my_lib_cell_name;
}
`
>3.Sort out all "AND" cell name that are inside library with pin direction
 
`foreach_in_collection my_pins [get_lib_pins sky130_fd_sc_hd__tt_025C_1v80/sky130_fd_sc_hd__and2_0/*] {
set my_pin_name [get_object_name $my_pins];
set pin_dir [get_lib_attribute $my_pin_name direction];
echo $my_pin_name $pin_dir;
}
`

#### Result:
![DC_D2SK2_L3 - Lab7 - Exploring - dotLib part2_0](https://user-images.githubusercontent.com/62828746/209026606-00b28107-5aae-40ba-b0a2-ea81a6ba4883.jpg)

 *List out all the “AND” cell’s name inside library*
 
![DC_D2SK2_L3 - Lab7 - Exploring - dotLib part2_1](https://user-images.githubusercontent.com/62828746/209026607-76ce8db8-2770-47e4-8f04-4f6ee84edbc8.jpg)

 *Sort out all "AND" cell name that are inside library*
 
![DC_D2SK2_L3 - Lab7 - Exploring - dotLib part2_2](https://user-images.githubusercontent.com/62828746/209026612-5e68d495-41cf-4183-8c16-421c1909deb2.jpg)

 *Sort out all "AND" cell name that are inside library with pin direction*
 
![DC_D2SK2_L3 - Lab7 - Exploring - dotLib part2_3](https://user-images.githubusercontent.com/62828746/209026614-a9864a77-7d05-4c99-9880-f6bc6e21b458.jpg)

 *Script to sort out pin’s name, direction and function*
 
![DC_D2SK2_L3 - Lab7 - Exploring - dotLib part2_4](https://user-images.githubusercontent.com/62828746/209026618-85317b19-28d2-4a6d-b89a-021b07bc06c8.jpg)

 *Command that able to quickly explore attribute of cell’s pins*
 
   </details>
 
 
  
  
## :bookmark: Day 8
### :bulb: Theory - SDC Part1 Clock - Clock Tree Modelling - Uncertainty

<details><summary> Clock Tree Modelling - Uncertainty </summary>

### **Introduction to CTS (Clock Tree Synthesis)**

![Introduction to CTS (Clock Tree Synthesis)](https://user-images.githubusercontent.com/62828746/209437450-4a772d0f-d288-4d47-848b-91d4edc70d95.jpg)
![Introduction to CTS (Clock Tree Synthesis)_1](https://user-images.githubusercontent.com/62828746/209437452-2b66e043-ecb9-4fcc-8cdb-309e0cf5820f.jpg)

* CTS: Process of distributing clock equally among all sequential circuit in design and is used to balance clock skew and reduce insertion latency.
* Puspose of CTS: To achieve zero/minimum skew or balanced skew by inserting buffers along the clock routes.
* CTS start point: Clock source
* CTS end point: Clock pins of sequential cells.
* In reality, pratical circuit has delay in clock and need CTS try to reduce/remove the delay and balance the clock in sequential circuit.

## **Clock Generation and Jitter**
![Clock Generation and Jitter](https://user-images.githubusercontent.com/62828746/209437453-54602b28-fdc2-425c-ab36-0ccf12fc86b7.jpg)
* Clock generator: Oscillator, PLL or External Clock Source
* All of the above clock sources have inherent variations in clock period due to stochastic effects.
* Due to stochastic effects, edegs attive within a window and location of edges varies from cycle within this window.
* Clock jitter - Typically caused by clock generator circuitry, noise, power supply variations, interference from nearby circuitry.

 ## **Clock Skew**
![Clock Skew](https://user-images.githubusercontent.com/62828746/209437448-90c4f261-17eb-45da-8809-2d3f06ae7466.jpg)
 
* Clock distribution: inclde network of wire or inverter. In pracrical, RC delay of wire resistance and gate load is very long.
* Variations in this delay cause clock to get to different elements at different times. This is called clock skew.
* Clock skew between two flip-flops represents the difference in arrival times of clock signal at the respective clock pins.
 

## **Clock Modelling**
![Clock Modelling](https://user-images.githubusercontent.com/62828746/209437454-1f7c41f1-ab1b-489d-8586-3f6723b63074.jpg)

+ Model clock for following:
  * Period
  * Source Latency: Time taken by clock source to generate clock.
  * Clock Network Latency: Time taken by clock distribution network.
  * Clock Skew: Clock path delay mismatches which cause differences in arrival of clock. CTS only will balance/minimize the clock and can't make clock to zero.
  * Jitter: Stochastic variation in the arrival of clock edge. Two type: Duty cycle jitter and period jitter.
 
+ Clock Uncertainty: Clock Skew and Jitter.
+ Post CTS, clock network is real and hence this modelled clock skew and clock network latency must be removed and actual clock delay should be calculated by the tool. 

 **Stage**      | **Clock Uncertainty**   |  **Timing Path** | **Explanation**
------------------   | ------------------  | ------------------ | ---------------------
Pre-CTS (Synthesis) | Clock Skew and Jitter | Ideal | Clock Skew: Delay imbalance between clock network. <br /> Jitter: Random variation in clock edge of clock source.
Post-CTS | Only Jitter | Practical clock tree is built, no more ideal clock. | Jitter: Random variation in clock edge of clock source.
 
   </details>


<details><summary> SDC Part2 IO delays </summary>

**TCL command**      | **Function**                                   | **Example**
------------------   | ---------------------------------------------   | --------------------------------------------- 
get_ports | Creates a collection of ports from the current design. Can assign these ports to a variable or pass them into another command | get_ports clk -> query port in design <br /> get_ports *clk* -> get collection of ports with name contains clk  <br /> get_ports * -> get all ports in design  <br /> get_ports * -filter "direction == in" -> list all input port 
get_clocks | Creates a collection of clocks from the current design. Can assign these clocks to a variable or pass them into another command. | get_clocks * -> get all clocks in design  <br />  get_clocks *clk* -> get collection of clock with name contains clk <br /> get_clocks* -filter "period > 10" -> list all clock with period more than 10ns <br /> get_attribute [get_clocks my_clk] is_generated -> get attribute (period/generated/shape) of the clock
get_cells | Creates a collection of cells from the current design relative to the current instance. Can assign these cells to a variable or pass them into another command. | get_cells * -hier -> List all cells across all hierachies in the design. (Physical and hierachical)
create_clock | Creates a clock object and defines its waveform in the current design | create_clock -name MY_CLK -per 5 [get_ports CLK] <br /> *clock must be created on clk source (PLL, oscilator) or primary IO pins (for external clock) <br />  create_clock -name MY_CLK -per 10 [get_ports CLK] -> 50% DC clock starting phase is HIGH <br />  create_clock -name MY_CLK -per 10 [get_ports CLK] -wave {5 10} -> 50% DC clock starting phase is LOW <br />  create_clock -name MY_CLK -per 10 [get_ports CLK] -wave {2.5 7.5} -> 50% DC clock starting phase is HIGH, but starting edge is not 0.
set_clock_latency | Specifies clock network latency. | set_clock_latency 3 MY_CLK -> set clk latency that modelling clk delay in network 
set_clock_uncertainty | Specifies uncertainty (skew) of clock networks. | set_clock_uncertainty 0.5 MY_CLK -> set uncertainty for network (skew + jitter)
set_input_delay | Sets input delay on pins or input ports relative to a clock signal. | set_input_delay -max 3 -min 0.5 [get_clocks MY_CLK][get_ports IN_*] -> signal delay must come most early in 0.5ns and most late in 3ns. All input signal are coming with respect to clock MY_CLK which created on port CLK.
set_input_transition | Sets the max_transition_rise, max_transition_fall, min_transition_rise, or min_transition_fall attributes to the specified transition values on the specified input and inout ports. | set_input_transition -max 1.5 -min 0.75 [get_ports IN_*] -> max and min transition of clk. 
 

   </details>


### :bulb: Theory - SDC Part3 generated_clk

<details><summary> SDC Part3 generated_clk </summary>

![DC_D3SK3_L1 - Lecture9 - SDC Part3 generated_clk](https://user-images.githubusercontent.com/62828746/209567323-21f89200-7286-4711-9e55-23f296e7dce4.jpg)
 
* Clock period at input port are different with output port due to propogation delay (network latency, uncertainty and etc)
* Hence, we need to create generated clock that used for capturing data at output ports which defined with respect to clock source (master clock).
 
![DC_D3SK3_L1 - Lecture9 - SDC Part3 generated_clk_1](https://user-images.githubusercontent.com/62828746/209568711-d3d7fe3b-c0d5-419f-9a94-dd7d960fd246.jpg)
 
+ Clock divider
  * Clock dividers are ubiquitous circuit that takes an input signal of a frequency fin and generates an output signal of a frequency fout, where fout = fin / n and ''n'' is an integer. 
  * Purpose: to divide a clock by even, odd or fractional numbers away from using external PLL circuits.
 
 
   </details>


### :pencil2: Lab Topic - Advanced constraints

<details><summary> Lab - Loading design get_cells, get_ports, get_nets </summary>

#### Steps:
> 1. Invoke dc 
>> csh -> to enable c shell
>> dc_shell -> invoke dc compiler
> 2. Read verilog file using command.
>> *read_verilog lab8_circuit.v*
>> *link*
> 3. Compile the design
>> *compile_ultra*
> 4. use command to select ports in the design.
>> *get_ports*

 `foreach_in_collection my_port [get_ports *] {
set my_port_name [get_object_name $my_port];
echo $my_port_name;
}
`
> 5. To know direction of the ports
>> *get_attribute [get_ports rst] direction*

 `foreach_in_collection my_port [get_ports *] {
set my_port_name [get_object_name $my_port];
set dir [get_attribute [get_ports $my_port_name] direction];
echo $my_port_name $dir;
}
`
> 5. To cells name and their type
>> *get_cells **
>> *get_attribute [get_cells U9] is_hierarchical*
>> *get_attribute [get_cells U12] is_hierarchical*
>> *get_attribute [get_cells REGA_reg] is_hierarchical*
>> *get_cells -hier -filter  "is_hierarchical == false"*
>> *get_cells -hier -filter  "is_hierarchical == true"* 

> 6. To get cell name in library
>> *get_attribute [get_cells REGA_reg] ref_name*

 `foreach_in_collection my_cell [get_cells * -hier] {
set my_cell_name [get_object_name $my_cell];
set rname [get_attribute [get_cells $my_cell_name] ref_name];
echo $my_cell_name $rname;
} 
`
> 7. Write in ddc format
>> *write -f ddc -out lab8_circuit.ddc*
> 8. Launch design vision, gui form of dc to see design implementation.
>> *read_ddc lab8_circuit.ddc*
 
#### Result:
![DC_D3SK2_L1 - Lab8 - Loading design get_cells, get_ports, get_nets_0](https://user-images.githubusercontent.com/62828746/209444103-b68e976e-ad9b-484d-813f-0f329ef63c84.jpg)
![DC_D3SK2_L1 - Lab8 - Loading design get_cells, get_ports, get_nets_1](https://user-images.githubusercontent.com/62828746/209444105-1a85dff0-7516-487c-9cd2-2cf48ec3181e.jpg)
![DC_D3SK2_L1 - Lab8 - Loading design get_cells, get_ports, get_nets_2](https://user-images.githubusercontent.com/62828746/209444106-912ab377-b622-474b-84fc-a58e1eada6ed.jpg)
![DC_D3SK2_L1 - Lab8 - Loading design get_cells, get_ports, get_nets_3](https://user-images.githubusercontent.com/62828746/209444107-6534a682-b45c-4e31-a860-846ea1bf798b.jpg)
![DC_D3SK2_L1 - Lab8 - Loading design get_cells, get_ports, get_nets_4](https://user-images.githubusercontent.com/62828746/209444110-f0e554e4-933c-4a17-bae4-6cb7d06ccf7a.jpg)
![DC_D3SK2_L1 - Lab8 - Loading design get_cells, get_ports, get_nets_5](https://user-images.githubusercontent.com/62828746/209444111-8fc5924a-fb16-43ee-97b6-a9598174bfe2.jpg)

   </details>
   
<details><summary> Lab - get_pins, get_clocks, querying_clocks </summary>

#### Steps:
 
> 1. use command to get pins in the design.
>> *get_pins*
 
`  foreach_in_collection my_pin [get_pins *] {     
 set pin_name [get_object_name $my_pin];                                                                                                      
 echo $pin_name;                                                                                                                               
 }
` 
> 2. use command to get pins direction in the design.
>> *get_attribute [get_pins REGA_reg/RESET_B] direction*
 
`  foreach_in_collection my_pin [get_pins *] {                                                                                                 
 set pin_name [get_object_name $my_pin];                                                                                                       
 set dir [get_attr [get_pins $pin_name ] direction];                                                                                          
 echo $pin_name $dir;                                                                                                                          
 }  
`
#### Result:
![DC_D3SK2_L2 - Lab9 get_pins, get_clocks, querying_clocks_0](https://user-images.githubusercontent.com/62828746/209445351-2f49ef3b-fbcb-4452-9024-1bf09ac360ef.jpg)
![DC_D3SK2_L2 - Lab9 get_pins, get_clocks, querying_clocks_1](https://user-images.githubusercontent.com/62828746/209445354-cd0ccc9f-93d8-4853-831f-e21713afb55d.jpg)
![DC_D3SK2_L2 - Lab9 get_pins, get_clocks, querying_clocks_2](https://user-images.githubusercontent.com/62828746/209445356-1e647c08-f623-4ac8-a8db-2ab329916c0c.jpg)
 
   </details>



<details><summary> Lab10 - create_clock waveform </summary>

#### Steps:
> 1. Report name of top module
>> *current_design*
> 2. create clock of period of 10ns for port CLK in design
>> *create_clock -name MYCLK per 10 [get_ports clk]*
>> *get_clocks **
>> *get_attr [get_clocks MYCLK] period*
>> *report_clocks **
> 3. create clock of period of 10ns, set rise/fall edge and set duty cycle clock.
>> *create_clock -name MYCLK -per 10 [get_ports clk] -wave {5 10}*
>> *create_clock -name MYCLK -per 10 [get_ports clk] -wave {0 2.5}*


#### Result:
![DC_D3SK2_L3 - lab10 - create_clock waveform_0](https://user-images.githubusercontent.com/62828746/209446676-fd9c9249-0158-477e-a4ea-2db2893228f2.jpg)
![DC_D3SK2_L3 - lab10 - create_clock waveform_1](https://user-images.githubusercontent.com/62828746/209446678-9083d6ac-35c2-477c-8a24-b12edc6e5ec6.jpg)
![DC_D3SK2_L3 - lab10 - create_clock waveform_2](https://user-images.githubusercontent.com/62828746/209446680-e8b0039a-b367-478e-82b0-23157fe98352.jpg)
![DC_D3SK2_L3 - lab10 - create_clock waveform_3](https://user-images.githubusercontent.com/62828746/209446682-473aedaa-f8a6-4288-9c46-8b1be2dbb1c6.jpg)
![DC_D3SK2_L3 - lab10 - create_clock waveform_4](https://user-images.githubusercontent.com/62828746/209446683-f0ee0bb8-f082-4cb0-a6c2-4c84d3d2226f.jpg)
 
   </details>


<details><summary> Lab11- Clock Network Modelling - Uncertainty, report_timing </summary>

#### Steps:
> 1. Modelling source latency for clock in design.
>> *set_clock_latency -source 1 [get_clocks MYCLK]*
> 2. Modelling network latency for clock in design. 
>> *set_clock_latency 1 [get_clocks MYCLK]**
> 3. Report timing path and see how clock latency and uncertainty effect timing path.
>> *set_clock_latency -source 2 [get_clocks MYCLK]*
>> *set_clock_latency 1 [get_clocks MYCLK]*
>> *set_clock_uncertainty -setup 0.5 [get_clocks MYCLK]*
>> *set_clock_uncertainty -hold 0.1 [get_clocks MYCLK]*
> 4. Report timing path for hold check and setup check.
>> *report_timing -to REGC_reg/D -delay min*
>> *report_timing -to REGC_reg/D -delay max*
 
#### Result:
![DC_D3SK2_L4 - Lab11- Clock Network Modelling - Uncertainty, report_timing_0](https://user-images.githubusercontent.com/62828746/209448152-68f099b8-af08-40b6-9a98-5debf572b4f9.jpg)
![DC_D3SK2_L4 - Lab11- Clock Network Modelling - Uncertainty, report_timing_1](https://user-images.githubusercontent.com/62828746/209448154-181f3552-4659-45c1-9d58-95849cf928fa.jpg)
![DC_D3SK2_L4 - Lab11- Clock Network Modelling - Uncertainty, report_timing_2](https://user-images.githubusercontent.com/62828746/209448155-5a47888e-57fb-4224-8efd-f4b359e32c92.jpg)
![DC_D3SK2_L4 - Lab11- Clock Network Modelling - Uncertainty, report_timing_3](https://user-images.githubusercontent.com/62828746/209448157-954dc698-e186-4e3d-8859-f3ebb8a9b119.jpg)
![DC_D3SK2_L4 - Lab11- Clock Network Modelling - Uncertainty, report_timing_4](https://user-images.githubusercontent.com/62828746/209448160-4dd11aca-5819-47a5-99e3-a981d690b6b3.jpg)
 
 
   </details>
   

<details><summary> Lab12- IO Delays </summary>

#### Steps:
> 1. Review input timing path and output timing path
>> *get_ports **
>> *report_timing -from IN_A*
>> *report_timing -to OUT_Y*
> 2. To review detail of all ports
>> *report_port -verbose*
> 3. Modelling the inputs of port
>> *set_input_delay -max 5 -clock [get_clocks MYCLK] [get_ports IN_A]*
>> *set_input_delay -max 5 -clock [get_clocks MYCLK] [get_ports IN_B]*
>> *report_timing -from IN_A -trans -net -cap*
>> *report_timing -from IN_A -trans -net -cap -nosplit -delay_type min*
> 3. Modelling the transition delay for path
>> *report_timing -from IN_A -trans -cap -nosplit > a*
>> *set_input_transition -max 0.3 [get_ports IN_A]*
>> *set_input_transition -max 0.3 [get_ports IN_B]* 
>> *set_input_transition -min 0.1 [get_ports IN_A]* 
>> *set_input_transition -min 0.1 [get_ports IN_B]*
>> *report_timing -from IN_A -trans -cap -nosplit > a_trans*
> 4. Modelling the output delay for path
>> *set_output_delay -max 1 -clock [get_clocks MYCLK] [get_ports OUT_Y]*
>> *set_output_delay -max 5 -clock [get_clocks MYCLK] [get_ports OUT_Y]*
>> *set_output_delay -min 1 -clock [get_clocks MYCLK] [get_ports OUT_Y]* 
>> *report_timing -to OUT_Y -cap -trans -nosplit > out_Y*
> 5. Modelling the output load for path 
>> *set_load -max 0.4 [get_ports OUT_Y]*
>> *report_timing -to OUT_Y -cap -trans -nosplit > out_load*

 
#### Result:
![DC_D3SK2_L5 - Lab12- IO Delays_0](https://user-images.githubusercontent.com/62828746/209539301-3eb6b499-8473-4826-b4f3-95b5f6107d03.jpg)
![DC_D3SK2_L5 - Lab12- IO Delays_1](https://user-images.githubusercontent.com/62828746/209539280-d926453b-6cde-4c3b-95f1-4c83a6db9917.jpg)
![DC_D3SK2_L5 - Lab12- IO Delays_2](https://user-images.githubusercontent.com/62828746/209539285-f7d295ca-685f-44b0-b63a-e3ec1483f39f.jpg)
![DC_D3SK2_L5 - Lab12- IO Delays_3](https://user-images.githubusercontent.com/62828746/209539287-60d3cc14-2544-4491-bcb7-66fb4db989cf.jpg)
![DC_D3SK2_L5 - Lab12- IO Delays_4](https://user-images.githubusercontent.com/62828746/209539292-f2075d46-439b-4093-bbd2-89d5a93e47bf.jpg)
![DC_D3SK2_L5 - Lab12- IO Delays_5](https://user-images.githubusercontent.com/62828746/209539293-44c61261-8167-4ce7-9062-29a2e9325cd9.jpg)
![DC_D3SK2_L5 - Lab12- IO Delays_6](https://user-images.githubusercontent.com/62828746/209539296-9a3dd47e-081c-4dd5-879c-3fa4cc903058.jpg)
![DC_D3SK2_L5 - Lab12- IO Delays_7](https://user-images.githubusercontent.com/62828746/209539299-4c909a9b-fa06-48d7-8647-738370a9678e.jpg)
![DC_D3SK2_L5 - Lab12- IO Delays_8](https://user-images.githubusercontent.com/62828746/209539300-c56d4bdf-9b9d-4a9a-8535-00414b17c0fc.jpg)

 
   </details>


<details><summary> Lab13 - generated_clocks </summary>

#### Steps:
> 1. Create generated clock
>> *create_generated_clock -name MYGEN_CLK -master MYCLK -source [get_ports clk] -div 1 [get_ports out_clk]*
> 2. To make timing path capture data at generated clock (MYGEN_CLK) instead of master clock (MYCLK).
>> *set_output_delay -max 5 [get_ports OUT_Y] -clock [get_clocks MYGEN_CLK]*
>> *set_output_delay -max 5 [get_ports OUT_Y] -clock [get_clocks MYGEN_CLK]*
>> *report_timing -to OUT_Y*
> 3. Reset design and read another design (lab8_circuit_modified), write a tcl with design constraints and source it.
>> *reset_design*
>> *sh gvim lab8_cons.tcl &*
>> *read_verilog lab8_circuit_modified.v*
>> *link*
>> *report_clocks*
>> *report_ports -verbose*


#### Result:
![DC_D3SK3_L2 - lab13 - generated_clocks_0](https://user-images.githubusercontent.com/62828746/209567295-489f7790-7fc9-4c20-9f2b-c65f297deddc.jpg)
![DC_D3SK3_L2 - lab13 - generated_clocks_1](https://user-images.githubusercontent.com/62828746/209567297-0ff7f46b-ee9d-411f-b7a2-464b303ab8d9.jpg)
![DC_D3SK3_L2 - lab13 - generated_clocks_2](https://user-images.githubusercontent.com/62828746/209567299-55fd671c-3103-4329-a564-f5b054c9d156.jpg)
![DC_D3SK3_L2 - lab13 - generated_clocks_4](https://user-images.githubusercontent.com/62828746/209567301-64967c1a-20cc-4709-9663-179b39f7fcd3.jpg)
 

   </details>


<details><summary> Lab15 - part1 Set_Max_delay </summary>

#### Steps:
> 1. Read lab14 circuit verilog file and use back constraints srcipt in previous lab session.
>> *read_verilog lab14_circuit.v*
>> *link*
>> *compile_ultra*
>> *report_timing* 
>> *source lab8_cons.tcl*
> 2. Modelling constraints for 3 new port (IN_C, IN_D and OUT_Z)
>> *all_registers -clock MYCLK* 
>> *all_registers -clock MYGEN_DIV_CLK* 
>> *all_inputs*
>> *all_outputs*
>> *report_timing -to OUT_Z*
>> *set_max_delay 0.1 -from [all_inputs] -to [get_ports OUT_Z]*
>> *compile_ultra*
>> *report_timing -to OUT_Z -sig 4* 
> 3. to see fanout of registers (endpoint) and can review how timing path start and ends.
>> *report_timing -from -IN_B -to OUT_Z* 
>> *report_timing -from IN_B -to OUT_Z* 
>> *report_timing -from IN_B -to OUT_Y* 
> 4. write ddc and review schematic
>> *reset_design*  
>> *read_ddc lab14.ddc*  
>> *design_vision*  
>> *read_ddc lab14.ddc*  
 
#### Result:
 
![DC_D3SK4_L2 - lab15 - part1 Set_Max_delay_0](https://user-images.githubusercontent.com/62828746/209601680-5d50fc9b-74cd-4249-bf26-84207ef99150.jpg)
![DC_D3SK4_L2 - lab15 - part1 Set_Max_delay_1](https://user-images.githubusercontent.com/62828746/209601669-65720d1a-585a-4df4-9134-9c4e3a66cde7.jpg)
![DC_D3SK4_L2 - lab15 - part1 Set_Max_delay_2](https://user-images.githubusercontent.com/62828746/209601670-3df745c0-77c0-431c-a0ea-954a1ab3105c.jpg)
![DC_D3SK4_L2 - lab15 - part1 Set_Max_delay_3](https://user-images.githubusercontent.com/62828746/209601674-efd6ba5d-1bfc-4615-9bcb-546fb8f7c564.jpg)
![DC_D3SK4_L2 - lab15 - part1 Set_Max_delay_4](https://user-images.githubusercontent.com/62828746/209601676-fc993850-c3ff-4284-b8d4-be1b44b102cc.jpg)
![DC_D3SK4_L2 - lab15 - part1 Set_Max_delay_5](https://user-images.githubusercontent.com/62828746/209601678-28e8fb0e-2854-47bc-9148-be56f5f7bbe7.jpg)
 
 
   </details>
   
   
<details><summary> Lab15 - part2 - VCLK </summary>

#### Steps:  
> 1. Create virtual clock   
>> *reset_design* 
>> *read_verilog lab14_circuit.v*  
>> *source lab8_con*  
>> *compile_ultra*  
>> *report_timing -to OUT_Z*  
> 2. Modeling delay constraints for created virtual clock timing path
>> *set_input_delay -max 5 [get_ports IN_C] -clock [get_clocks MYVCLK]*  
>> *set_input_delay -max 5 [get_ports IN_D] -clock [get_clocks MYVCLK]*  
>> *set_output_delay -max 5 [get_ports OUT_Z] -clock [get_clocks MYVCLK]*  
>> *set_output_delay -max 4.9 [get_ports OUT_Z] -clock [get_clocks MYVCLK]* 
>> *report_timing -to OUT_Z -sig 4* 
>> *report_port -verbose* 

#### Result:   
   
![DC_D3SK4_L3 - Lab15 - part2 - VCLK_0](https://user-images.githubusercontent.com/62828746/209607217-5df5a2e9-d1ac-4b63-8c31-3b46407cd9d9.jpg)
![DC_D3SK4_L3 - Lab15 - part2 - VCLK_1](https://user-images.githubusercontent.com/62828746/209607221-548fca9c-aa9e-41aa-83f8-793c479e571c.jpg)
![DC_D3SK4_L3 - Lab15 - part2 - VCLK_2](https://user-images.githubusercontent.com/62828746/209607222-3107179d-da8f-449a-9b01-b7006fd276bc.jpg)
   
   
   </details>

  
  
  
## :bookmark: Day 9 
### :bulb: Theory - Optimizations Combinational Opt


<details><summary> Optimizations Combinational Opt </summary>

## **Optimization Goals**
+ Cost function based optimizations:
  * Optmization till cost is met
  * Over optimization of a goal might harm other 
  * Goals for synthesis are contradictory and need to trade off others goal when optimize one of them.
  * For example: Optimize timing will get faster cell, but due to increased size of transistor (increase current flow), power and area quality is lower.
 
 **Goals for Synthesis**      | **Cost Function**   
---------------------------   | ------------------  
Meet Timing | IO Delay, Clock Period, Max-delay 
Meet Area | Area goals
Meet Power | Power goals
 
## **Combinational Logic Optimisation**
![DC_D4SK1_L1 - Lecture11 - Optimizations Combinational Opt_0](https://user-images.githubusercontent.com/62828746/210125149-7d4c9812-131f-4344-a3b5-c4d4463a1b61.jpg)
![DC_D4SK1_L1 - Lecture11 - Optimizations Combinational Opt_1](https://user-images.githubusercontent.com/62828746/210125152-1ce27e20-a34c-47de-9b06-dcf428627b1b.jpg)
![DC_D4SK1_L1 - Lecture11 - Optimizations Combinational Opt_2](https://user-images.githubusercontent.com/62828746/210125153-754c5be7-a85f-42d1-a873-6f4086b519fd.jpg)
![DC_D4SK1_L1 - Lecture11 - Optimizations Combinational Opt_3](https://user-images.githubusercontent.com/62828746/210125155-9dfc27bb-1bb3-4fb4-82fc-12ed3ee96b58.jpg)
![DC_D4SK1_L1 - Lecture11 - Optimizations Combinational Opt_4](https://user-images.githubusercontent.com/62828746/210125156-c7d95b20-a954-441f-9125-761319bbe596.jpg)
 
   </details>


### :bulb: Theory - Sequential Optimizations

<details><summary> Sequential Optimizations </summary>
  
## **Sequential Logic Optimisation** 
![DC_D4SK1_L2 - Lecture12 Sequential Optimizations_0](https://user-images.githubusercontent.com/62828746/210125158-2cc5fc40-1bf4-42bf-ac86-4e476d944e5a.jpg)
![DC_D4SK1_L2 - Lecture12 Sequential Optimizations_1](https://user-images.githubusercontent.com/62828746/210125160-68faf4df-262c-4819-9a45-d280708dd070.jpg)
![DC_D4SK1_L2 - Lecture12 Sequential Optimizations_2](https://user-images.githubusercontent.com/62828746/210125163-50b56a8b-6555-41ec-874b-dbbce0f352b5.jpg)
![DC_D4SK1_L2 - Lecture12 Sequential Optimizations_3](https://user-images.githubusercontent.com/62828746/210125164-b2f0ca73-8277-4ecb-ba59-bdbefa2ad597.jpg)
![DC_D4SK1_L2 - Lecture12 Sequential Optimizations_4](https://user-images.githubusercontent.com/62828746/210125166-064ca50f-3a44-47d1-91e9-758a7d429fc4.jpg) 
 
## **Controlling Sequential Optimization in DC**
+ Apply constant propagation optimization to circuit:
  * compile_seqmap_propagate_constants <true/false>
+ Apply unloaded output optimization to circuit:
  * compile_delete_unloaded_sequential_cells <true/false>
+ Advanced optimization:
* compile_register_replication <true/false>
 
   </details>


### :bulb: Theory - Special optimizations


<details><summary> Special optimizations </summary>

## **Retiming Optimization**
 
![DC_D4SK3_L1 - Lecture13 special optimizations_0](https://user-images.githubusercontent.com/62828746/210257175-a9128195-d448-4a45-87e2-54d6f47e9013.jpg)
 
* Retiming is to optimize algorithm and improve the performance of circuit. 
* Retiming will divide and move registers that has negative slack to the side with positive slack. This will balance the slack on both sides of sequential element.
* Intermediate value: uncertain value that might an issues when debug and analyze circuit compared to rtl.
 
## **Boundary Optimization**

![DC_D4SK3_L1 - Lecture13 special optimizations_1](https://user-images.githubusercontent.com/62828746/210257181-ab343854-2db2-46d2-8320-f2772990b04b.jpg)
 
* Boundary Optimization - Disorbing boundary of the module and combine register of both module into one.
* Funcational DV (Design Verification) might have issues when debug and analyze circuit compared to rtl.
 
## **Multi-cycle Path**

![DC_D4SK3_L1 - Lecture13 special optimizations_2](https://user-images.githubusercontent.com/62828746/210257183-689fe70a-685b-4847-8da4-fc567bb10337.jpg)
 
* Input A and B will load data first and waiting for sel to select data.
* Sel will be one cycle delay of enable due to delay in flop.
* Both path are in used and can't optmized A timing and B timing path into a single path.

 
## **False Path**
 
![DC_D4SK3_L1 - Lecture13 special optimizations_3](https://user-images.githubusercontent.com/62828746/210257187-c17e9a6b-7cd0-442a-a6eb-1d2e530ce9fe.jpg)
 
* Set false path when clock 1 and clock 2 path has no relation.
* FN_sel is a constant signal during operation.
* Between transferring data within FN_sel to OUT_DATA there are lots of idle timing cycle.
* Hence, it's not valid timing path and can be set as false path.
 
## **External Load and Internal Load** 
 
![DC_D4SK3_L1 - Lecture13 special optimizations_4](https://user-images.githubusercontent.com/62828746/210257192-a934630a-97ec-48fa-9972-3e2a6e226791.jpg)
 
* Extra extra load (Load 2) will cause increase in capacitance and delay in Output Logic.
* Internal timing path is effected and failed.
* Putting an isolated ports which is a buffer, and set it to ouput Y.
* Like this extra load will not be seen by internal path. And will avoid internal timing path violation.
 
   </details> 
 

 
 
### :pencil2: Lab Topic - Combinational optimizations

<details><summary> Lab16 - part1 Combinational_optimizations </summary>

#### Steps:
> 1. Read verilog opt_check file using command
>> *read_verilog opt_check.v*
>> *report_timing*
>> *link*
>> *compile_ultra*
>> *report_timing -to y2*
>> *report_timing -to y1*
>> *write -f ddc -out opt_check_ddc.v*
> 2. Load design vison and read ddc file
>> *sh*
>> *design_vision*
>> *read_ddc opt_check.ddc*
> 3. Read verilog opt_check2 file using command
>> *read_verilog opt_check2.v*
>> *link*
>> *compile_ultra*
 > 4. Read verilog opt_check3 file using command
>> *read_verilog opt_check3.v*
>> *link*
>> *compile_ultra*
> 5. Read verilog opt_check4 file using command
>> *read_verilog opt_check4.v*
>> *link*
>> *compile_ultra*
 

#### Result:
![DC_D4SK2_L1 - Lab16 - part1 Combinational_optimizations_0](https://user-images.githubusercontent.com/62828746/210209779-2aa6b522-24f7-4888-a8e2-1bf9cdc0c0ef.jpg)
![DC_D4SK2_L1 - Lab16 - part1 Combinational_optimizations_1](https://user-images.githubusercontent.com/62828746/210209781-daa91ec5-f6bb-4d29-89e9-c199d2fb6697.jpg)
![DC_D4SK2_L1 - Lab16 - part1 Combinational_optimizations_2](https://user-images.githubusercontent.com/62828746/210209786-9de2f14b-9a9b-42ee-88fb-2e640f205274.jpg)
![DC_D4SK2_L1 - Lab16 - part1 Combinational_optimizations_3](https://user-images.githubusercontent.com/62828746/210209698-3b0b4a34-ceb3-4df5-8cb4-27d85ac16086.jpg)
![DC_D4SK2_L1 - Lab16 - part1 Combinational_optimizations_4](https://user-images.githubusercontent.com/62828746/210209704-04bd2553-2908-44f2-bbfe-8c323f5b035c.jpg)
![DC_D4SK2_L1 - Lab16 - part1 Combinational_optimizations_5](https://user-images.githubusercontent.com/62828746/210209706-87ccbc5c-41f7-4953-9d18-67591f270738.jpg)
![DC_D4SK2_L1 - Lab16 - part1 Combinational_optimizations_6](https://user-images.githubusercontent.com/62828746/210209707-176df687-c4c3-45aa-b79a-68df563602a6.jpg)
![DC_D4SK2_L1 - Lab16 - part1 Combinational_optimizations_7](https://user-images.githubusercontent.com/62828746/210209711-bbcc599a-efef-4e79-b3d8-ee70090d7e24.jpg)
![DC_D4SK2_L1 - Lab16 - part1 Combinational_optimizations_8](https://user-images.githubusercontent.com/62828746/210209714-dc86303c-c713-4af9-b23b-fd0cdbf38e9e.jpg)
![DC_D4SK2_L1 - Lab16 - part1 Combinational_optimizations_9](https://user-images.githubusercontent.com/62828746/210209719-de005e3e-996c-4bae-a261-62ec565537bf.jpg)
![DC_D4SK2_L1 - Lab16 - part1 Combinational_optimizations_10](https://user-images.githubusercontent.com/62828746/210209733-e653a12d-6eb5-479c-a305-8e64cfb02207.jpg)

 
   </details>


<details><summary> Lab16 - part2 resource sharing optimizations </summary>

#### Steps:
> 1. Read verilog resource_sharing_mult_chec file using command
>> *sh gvim resource_sharing_mult_check.v*
>> *read_verilog resource_sharing_mult_check.v*
>> *link*
>> *compile_ultra*
>> *report_area*
> 2. Set delay to circuit and see timing before and after compile ultra
>> *set_max_delay -from [all_inputs] -to [all_outputs] 2.5* 
>> *report_timing* 
>> *compile_ultra*
>> *report_timing* 
> 3. Set delay to sel in circuit and see timing before and after compile ultra   
>> *set_max_delay -from sel -to [all_outputs] 0.1* 
>> *report_timing* 
>> *compile_ultra* 
>> *report_timing* 
> 4. set constraints to area and run optimization again
>> *set_max_area 800* 
>> *compile_ultra* 
>> *report_timing*

#### Result:
![DC_D4SK2_L2 - Lab16 - part2 resource sharing optimizations_0](https://user-images.githubusercontent.com/62828746/210209739-a2839999-5013-4482-b8dd-e8fc21b47043.jpg)
![DC_D4SK2_L2 - Lab16 - part2 resource sharing optimizations_1](https://user-images.githubusercontent.com/62828746/210209748-726788fd-d024-4e4b-8766-c82c162db2d0.jpg)
![DC_D4SK2_L2 - Lab16 - part2 resource sharing optimizations_2](https://user-images.githubusercontent.com/62828746/210209750-9970a294-34e0-49d4-b034-74c85a141df6.jpg)
![DC_D4SK2_L2 - Lab16 - part2 resource sharing optimizations_3](https://user-images.githubusercontent.com/62828746/210209752-eb3c1496-2539-4631-9fc2-1d8173e2ae91.jpg)
![DC_D4SK2_L2 - Lab16 - part2 resource sharing optimizations_4](https://user-images.githubusercontent.com/62828746/210209766-d21fb158-29ac-421c-a7d5-ceec0b147f0d.jpg)
![DC_D4SK2_L2 - Lab16 - part2 resource sharing optimizations_5](https://user-images.githubusercontent.com/62828746/210209771-8aacc393-89db-4339-b59b-26f7a7c6cf13.jpg)
![DC_D4SK2_L2 - Lab16 - part2 resource sharing optimizations_6](https://user-images.githubusercontent.com/62828746/210209772-3840b058-590c-47fc-8fbd-3cf894205d95.jpg)
![DC_D4SK2_L2 - Lab16 - part2 resource sharing optimizations_7](https://user-images.githubusercontent.com/62828746/210209775-b5baa2e6-90ab-4020-b938-5faa864eaa47.jpg)
![DC_D4SK2_L2 - Lab16 - part2 resource sharing optimizations_8](https://user-images.githubusercontent.com/62828746/210209776-41b3fdd3-70ce-43d0-a5a3-9c19a2e03ef2.jpg)

   </details>
 
 
<details><summary> Lab17 - seq optimizations </summary>

#### Steps:
> Sequential optimization file review and read verilog file
>> *read_verilog dff_const1.v*
>> *link*
>> *compile_ultra*
> 2. echo cell name and reference name
/ foreach_in_collection my_cells [get_cells *] {
set cell_name [get_object_name $my_cells];
set rn [get_attr [get_cells $cell_name] ref_name]; echo $cell_name $rn;
}
/
> 3. LOad design vision gui and read dff_const1.v
>> *csh* 
>> *design_vision*
>> *read_verilog dff_const1.v*  
>> *link*
>> *compile_ultra*
> 4.  LOad design vision gui and read dff_const2.v
>> *read_verilog dff_const2.v*  
>> *link*
>> *compile_ultra*
> 5. Load design vision gui and read dff_const3.v
>> *read_verilog dff_const3.v*  
>> *link*
>> *compile_ultra*
> 6. Try to turn-off the constant propagation optimization of dff_const2.v design
>> *set compile_seqmap_propagate_constants false*
>> *link*
>> *compile_ultra*  
> 7. Run simulation by apply RTL Design (dff_const3.v) and testbench (dff_const3.v) as inputs.
>> */p/hdk/pu_tu/prd/sams/mig76_wlw/setup/enter_p31 -cfg ip76p31r08hp7rev03 -ov ./*
>> *vcs dff_const3.v tb_dff_const3.v*
>> *./simv*
>> *dve -full64 &*
> 8. Try to turn-off the constant propagation optimization of dff_const4.v design
>> *read_verilog dff_const4.v*  
>> *link*
>> *compile*
>> *set compile_seqmap_propagate_constants true*  
>> *compile*
> 9.  Load design vision gui and read dff_const5.v
>> *read_verilog dff_const5.v*  
>> *link*
>> *compile_ultra*
> 10. Run simulation by apply RTL Design (dff_const5.v) and testbench (dff_const5.v) as inputs.
>> *vcs dff_const3.v tb_dff_const3.v*
>> *./simv*
>> *dve -full64 &*
 
 
#### Result:

![DC_D4SK2_L3 - lab17 - seq optimizations_0](https://user-images.githubusercontent.com/62828746/210243639-d680662b-d3a5-4483-9b22-748f59a536c8.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_1](https://user-images.githubusercontent.com/62828746/210243648-564dd79e-890b-43f8-b1df-ea5a68e5ebbc.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_2](https://user-images.githubusercontent.com/62828746/210243651-93c88160-f145-44f8-a41e-1f4465643f03.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_3](https://user-images.githubusercontent.com/62828746/210243653-657e5581-b27e-4038-b50f-2541e343bfb3.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_4](https://user-images.githubusercontent.com/62828746/210243656-b1d84e97-bc6b-4367-ac71-e34aab25ef76.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_5](https://user-images.githubusercontent.com/62828746/210243658-26549747-e6b1-4fdc-8328-cb07a815c34f.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_6](https://user-images.githubusercontent.com/62828746/210243661-9f3b519a-17bf-477f-858e-69a0dede8106.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_7](https://user-images.githubusercontent.com/62828746/210243665-0cff3ebb-c0c1-490b-afd2-ed450241cf43.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_8](https://user-images.githubusercontent.com/62828746/210243671-83683976-3081-483d-9441-c864c10d5c04.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_9](https://user-images.githubusercontent.com/62828746/210243677-b2792c57-1b0c-4ed0-9625-2c5892465c1a.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_10](https://user-images.githubusercontent.com/62828746/210243680-cd30f1bb-0d0f-4408-ba96-f8de27b8dab3.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_11](https://user-images.githubusercontent.com/62828746/210243682-ebac65d8-28ab-4263-8ff9-9e8e8b33293d.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_12](https://user-images.githubusercontent.com/62828746/210243691-65e78a7c-1343-4496-b9d1-c20b1ba9d8bc.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_13](https://user-images.githubusercontent.com/62828746/210243752-43142321-24af-41bf-82d2-c96d13ba9b33.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_14](https://user-images.githubusercontent.com/62828746/210243757-70487f3d-f843-4265-9a6c-479bbd0a5b1a.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_15](https://user-images.githubusercontent.com/62828746/210243762-ef25eecf-2fef-459b-b563-e7e9f896eef6.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_16](https://user-images.githubusercontent.com/62828746/210243767-0cfa2326-c280-487f-9a1e-b0cfde0789b2.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_17](https://user-images.githubusercontent.com/62828746/210243775-8a1e36d7-da49-4a72-8cbc-2f6893294175.jpg)
![DC_D4SK2_L3 - lab17 - seq optimizations_18](https://user-images.githubusercontent.com/62828746/210243791-842fad99-b91f-49fa-9207-385e46f668d9.jpg)


   </details>
 
<details><summary> Lab18 - Boundary Optimization </summary>

#### Steps:
> 1.  Load design vision gui and check_boundary.v
>> *read_verilog check_boundary.v*  
>> *link*
>> *compile_ultra*
>> *write -f ddc -out boundary.ddc*
>> *get_cells*
>> *read_ddc boundary.ddc*
> 2. Set boundary optimization to false and compare to after optimized.
>> *get_cells*
>> *get_pins u_im/**
>> *set_boundary_optimization u_im false*
>> *link*
>> *compile_ultra*

#### Result:
![DC_D4SK4_L1 - Lab18 - Boundary Optimization_0](https://user-images.githubusercontent.com/62828746/210260992-0d1364a0-7f6e-4bb8-9855-366a1c8ef846.jpg)
![DC_D4SK4_L1 - Lab18 - Boundary Optimization_1](https://user-images.githubusercontent.com/62828746/210260995-05333d9a-c904-4ffa-8dc9-ce6a5ec5098f.jpg)
![DC_D4SK4_L1 - Lab18 - Boundary Optimization_2](https://user-images.githubusercontent.com/62828746/210260998-691c4da3-5075-4605-8bac-6ce9a717ce93.jpg)
![DC_D4SK4_L1 - Lab18 - Boundary Optimization_3](https://user-images.githubusercontent.com/62828746/210261000-84efaad2-aa50-4ac9-b174-f392768a3cc1.jpg)

   </details>

<details><summary> Lab19 - Register Retiming </summary>

#### Steps:
> 1. Load design vision gui and check_reg_retime.v
>> *read_verilog check_reg_retime.v*
>> *link*
>> *compile*
>> *report_timing*
> 2. Source constraints and try to fix slack by optimizing with retiming.
>> *source reg_retime_cons.tcl*
>> *report_timing*
>> *compile_ultra -retime*
 
 
#### Result: 
![DC_D4SK4_L2 - Lab19 - Register Retiming_0](https://user-images.githubusercontent.com/62828746/210263587-0c9daf54-28b5-4178-835b-2074898e9a2f.jpg)
![DC_D4SK4_L2 - Lab19 - Register Retiming_1](https://user-images.githubusercontent.com/62828746/210263590-42e27fc1-1853-4509-a1bc-80265230ec37.jpg)
![DC_D4SK4_L2 - Lab19 - Register Retiming_2](https://user-images.githubusercontent.com/62828746/210263595-f8d2bb42-1593-4395-ba77-52c999916732.jpg)
![DC_D4SK4_L2 - Lab19 - Register Retiming_3](https://user-images.githubusercontent.com/62828746/210263597-a95da766-5921-4d0a-9e46-8df13bb82458.jpg)
![DC_D4SK4_L2 - Lab19 - Register Retiming_4](https://user-images.githubusercontent.com/62828746/210263598-01c360e3-8c95-45d8-a2fc-f18f30bbe185.jpg)
 
 
   </details> 
 
 
<details><summary> Lab20 - Isolating output ports </summary>

#### Steps:
> 1.  Load design vision gui and check_boundary.v
>> *read_verilog check_boundary.v*  
>> *link*
>> *compile_ultra* 
> 2.  Set isolate ports (buffer) to prevent internal timing path failed due to external load.
>> *set_isolate_ports -type buffer [all_outputs]* 
>> *compile_ultra* 
 
#### Result:
![DC_D4SK4_L3 - Lab20 - Isolating output ports_0](https://user-images.githubusercontent.com/62828746/210266473-3144c0a6-c63d-4438-a649-38d1bb796f6b.jpg)
![DC_D4SK4_L3 - Lab20 - Isolating output ports_1](https://user-images.githubusercontent.com/62828746/210266477-09a0ccd1-278f-4d72-bc86-055acfcabb90.jpg)
![DC_D4SK4_L3 - Lab20 - Isolating output ports_2](https://user-images.githubusercontent.com/62828746/210266479-a98f3664-1ece-4b69-914d-817501a1e343.jpg)
![DC_D4SK4_L3 - Lab20 - Isolating output ports_3](https://user-images.githubusercontent.com/62828746/210266482-f4aa46db-5320-4274-9b56-6c314097aa12.jpg)
![DC_D4SK4_L3 - Lab20 - Isolating output ports_4](https://user-images.githubusercontent.com/62828746/210266484-584947d8-0141-4d8c-9220-9d5a063f6725.jpg) 
 
   </details> 
 
<details><summary> Lab21 - MultiCycle path </summary>

#### Steps:
> 1.  Load design vision gui and mcp_check.v
>> *read_verilog mcp_check.v*  
>> *link*
>> *compile_ultra*

> 2. write constraints to multicycle path.
>> *source mcp_check_cons.tcl* </br>
>> *set multicycle_path -setup 2 -to prod_reg[*]/D -from [all_inputs]*</br>
>> *report_timing -to prod_reg[*]/D*</br>
>> *report_timing -from [all_inputs] -to prod_reg[*]/D*</br>
>> *set_multicycle_path -setup 2 -to prod_reg[*]/D -from [all_inputs]*</br>
>> *set_isolate_ports -type buffer [all_outputs]*</br>
>> *compile_ultra*</br>
>> *report_timing -inp -cap -trans -sig 4 -nosplit*</br>
 
#### Result:
![DC_D4SK4_L4 - Lab21 - MultiCycle path_0](https://user-images.githubusercontent.com/62828746/210269360-06fa73b8-e6a8-4f9a-bef2-e8bfec8c2c72.jpg)
![DC_D4SK4_L4 - Lab21 - MultiCycle path_2](https://user-images.githubusercontent.com/62828746/210269365-e64f4c48-ad93-476d-868a-2f293f8b92c8.jpg)
![DC_D4SK4_L4 - Lab21 - MultiCycle path_3](https://user-images.githubusercontent.com/62828746/210269368-77fe6a76-d199-45b7-9d15-054b1228bb40.jpg)
![DC_D4SK4_L4 - Lab21 - MultiCycle path_4](https://user-images.githubusercontent.com/62828746/210269369-a72c2edf-efac-4cfd-bcf8-46198abebc37.jpg)
![DC_D4SK4_L4 - Lab21 - MultiCycle path_5](https://user-images.githubusercontent.com/62828746/210269371-e6c2b980-92ea-4c54-ac14-3f3afc27db31.jpg) 
 
   </details>  
 
   
## :bookmark: Day 10 
### :bulb: Theory - Lecture Report timing


<details><summary> Lecture Report timing </summary>

## **Propagation Delay**
![DC_D5SK1_L2 - Lab Report timing_0](https://user-images.githubusercontent.com/62828746/210286621-632d6186-b9e4-4b0b-bc8f-9da8b801b909.jpg)

* Propagation delay is the time required for the input to be propagated to the output.
* Propogation delay of rise and fall are difference 
 
![DC_D5SK1_L2 - Lab Report timing_1](https://user-images.githubusercontent.com/62828746/210286624-59f3686e-04d1-45ef-bfb3-641b01137772.jpg)

## **Summary of Command Used to Verify/Confirm Design Constraints**
 **Command**      | **Function**      | **Example**
---------------   | ---------------   | --------------- 
check_design | Checks the current design for consistency | ![check_design](https://user-images.githubusercontent.com/62828746/210331816-b8b6fd8a-b755-47e1-b013-931e5be0183a.jpg)
check_timing | Warns about possible timing problems in the current design. | ![Check_timing](https://user-images.githubusercontent.com/62828746/210331802-6241e61e-d54e-4e4b-b8b1-94f9359db772.jpg)
report_constraints | Displays constraint-related information about a design. | ![Report_constraints](https://user-images.githubusercontent.com/62828746/210331810-56476c5b-d257-492e-8546-a942e17b31dd.jpg)
report_constraint -all_violators | List out all violating constraints | ![Report_constraints –all_violators and set_max_cap](https://user-images.githubusercontent.com/62828746/210331807-5960a661-338b-424c-aaf7-568fa05d4c51.jpg)
set_max_capacitance | Sets the max_capacitance attribute to a specified value on the specified ports and designs. Mainly for breaking/buffering the High Fanout Net (HFN) | ![set_max_cap](https://user-images.githubusercontent.com/62828746/210331814-69b39b1e-d58b-4d3e-84e3-0cb8a770fe07.jpg)  
set_max_transition |  Sets the max_transition attribute to a specified value on specified ports or designs. Set max trans and max cap properly to ensure HFN will be taken care. | ![set_max_trans](https://user-images.githubusercontent.com/62828746/210374748-1ad6a6ef-c271-46b2-b2e2-961817f45b53.jpg)

## **Summary of Synthesis.tcl**
![synthesis tcl](https://user-images.githubusercontent.com/62828746/210385075-4b785c6d-b307-4f24-9408-953d98e00f60.jpg)

 
## **Summary of Flow**
![flow summary](https://user-images.githubusercontent.com/62828746/210385071-37351c20-bf8d-4a93-9c81-9e05bd2c5ea6.jpg)
   
  
   </details> 
 
 
### :pencil2: Lab Topic - Lab Report timing

<details><summary>  Lab Report timing </summary>

#### Steps:
> 1. Read verilog lab8_circuit_modified.v, set constraints to circuit and review timing path report.
>> *read_verilog lab8_circuit_modified.v*</br>
>> *sh gvim lab8_cons_modified.tcl*</br>
>> *link*</br>
>> *source lab8_cons_modified.tcl*</br>
>> *compile_ultra*</br>
>> *report_timing -trans -nets -input -cap -nosplit -sig 4*</br>
>> *report_timing -trans -nets -input -cap -nosplit -sig 4 -from IN_A*</br>
>> *report_timing -rise_from IN_A  -trans -nets -input -cap -nosplit -sig 4*</br>
>> *report_timing -rise_from IN_A  -trans -nets -input -cap -nosplit -sig 4 -to REGA_reg/D*</br>
>> *report_timing -delay min -from IN_A*</br>
>> *report_timing -thr U15/Y*</br>
>> *report_timing -thr U15/Y -delay min*</br>


#### Result:
![DC_D5SK1_L2 - Lab Report timing_0](https://user-images.githubusercontent.com/62828746/210286663-d25b9913-1f2a-4b2c-8b1f-5613123ad36c.jpg)
![DC_D5SK1_L2 - Lab Report timing_1](https://user-images.githubusercontent.com/62828746/210286665-8b5d71be-f57a-417a-a5d2-2dfefa0f265a.jpg)
![DC_D5SK1_L2 - Lab Report timing_2](https://user-images.githubusercontent.com/62828746/210286667-abc58b9c-9730-4d80-aa39-99c63d67d798.jpg)
![DC_D5SK1_L2 - Lab Report timing_3](https://user-images.githubusercontent.com/62828746/210286668-5672ae85-94bd-4438-9556-6112975a0d74.jpg)
![DC_D5SK1_L2 - Lab Report timing_4](https://user-images.githubusercontent.com/62828746/210286670-fe6e560b-46b7-4d99-84bc-e430b2003b2f.jpg)
![DC_D5SK1_L2 - Lab Report timing_5](https://user-images.githubusercontent.com/62828746/210286672-8ed0cfad-c7ea-4368-8f99-a8c40bf15a10.jpg)
 
   </details> 
 
 
<details><summary>  Lab Check_timing, Check_design, Set_max_capacitance, HFN </summary>

#### Steps:
> 1. Read verilog lab8_circuit_modified.v, set constraints to circuit and review timing path report.
>> *read_verilog lab8_circuit_modified.v*</br>
>> *link*</br>
>> *check_design*</br>
>> *compile_ultra*</br>
>> *check_timing*</br>
>> *report_constraints*</br>
>> *report_timing*</br>
> 2. Read verilog mux_generate.v, set constraints to circuit and review timing path report.
>> *sh gvim mux_generate.v &*</br>
>> *read_verilog mux_generate_128_1.v*</br>
>> *read_verilog mux_generate_128_1.v*</br>
>> *check_design*</br>
>> *link*</br>
>> *compile_ultra*</br>
>> *write -f verilog -out mux_generate_128_1_net.v*</br>
>> *sh gvim mux_generate_128_1_net.v &*</br>
>> *get_cells * -hier -filter "is_sequential == true"*</br>
>> *get_cells * -hier -filter "is_sequential == false"*</br>
>> *report_timing -net -cap*</br>
>> *check_timing*</br>
>> *set_max_delay -from [all_inputs] -to [all_outputs] 3.5*</br>
>> *report_timing*</br>
>> *set_max_capacitance 0.025 [current_design]*</br>
>> *report_constraint -all_violators*</br>
>> *compile_ultra*</br>
>> *check_timing*</br>
>> *report_timing -net -cap -sig 4*</br>
> 3. Read verilog en_128.v, set constraints to circuit and review timing path report.
>> *sh gvim en_128.v*</br>
>> *read_verilog en_128.v*</br>
>> *link*</br>
>> *compile_ultra*</br>
>> *report_timing -from en -inp -nets -cap*</br>
>> *set_max_capacitance 0.03 [current_design]*</br> 
>> *report_constraints*</br>
>> *compile_ultra*</br> 
>> *report_timing -from en -inp -nets -cap -sig 4*</br>
>> *write -f ddc -out en_128.ddc*</br> 

> 3. Set maximum transition constraints to circuit and to fix HFN and delay that cause transition violation.
>> *report_timing -from en -inp -nets -cap -sig*</br>
>> *set_max_transition 0.150 [current_design]*</br>
>> *report_constraints*</br>
>> *report_constraints -all_violators*</br>
>> *compile_ultra*</br>
>> *report_timing -nets -cap -nets -inp -sig 4 -nosplit*</br>

#### Result: 
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_0](https://user-images.githubusercontent.com/62828746/210289570-1cb6d4dd-fac3-4263-959f-ccb66f124d44.jpg)
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_1](https://user-images.githubusercontent.com/62828746/210289574-ba92563d-33c2-4983-8cc9-147908fc6c2d.jpg)
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_2](https://user-images.githubusercontent.com/62828746/210289575-cd5bf395-8e6e-42d1-823b-feecf91fd8dd.jpg)
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_3](https://user-images.githubusercontent.com/62828746/210289577-1025f2a2-cc64-4cfc-b86c-79fdab19de66.jpg)
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_4](https://user-images.githubusercontent.com/62828746/210289579-d181e26c-c029-420f-89aa-2330ec6ccaaf.jpg)
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_5](https://user-images.githubusercontent.com/62828746/210289580-f888d41b-0a1f-4470-adbf-76b3c71542f6.jpg)
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_6](https://user-images.githubusercontent.com/62828746/210289583-26c4d407-3751-49ed-984c-72fbb43ded05.jpg)
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_7](https://user-images.githubusercontent.com/62828746/210289584-2f9f6af4-b14a-41df-b22a-f51bc5bfb0dc.jpg)
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_8](https://user-images.githubusercontent.com/62828746/210289585-92586c2a-282f-412c-90a9-a5bd069145f5.jpg)
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_9](https://user-images.githubusercontent.com/62828746/210289588-319d2a2d-80c7-49c3-ab66-26dec25cfea9.jpg)
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_10](https://user-images.githubusercontent.com/62828746/210289590-008f5774-27f4-4d21-b542-a3c693137810.jpg)
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_11](https://user-images.githubusercontent.com/62828746/210289594-d4a97da6-a8c1-44c0-8326-938c47779eec.jpg)
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_12](https://user-images.githubusercontent.com/62828746/210375783-ee248579-f238-4cba-848e-ae3a88f26ac6.jpg)
![DC_D5SK1_L3 - Lab Check_timing, Check_design, Set_max_capacitance, HFN_13](https://user-images.githubusercontent.com/62828746/210375787-2613d223-a42e-4ebb-afde-a5911c7a1189.jpg)

 
 
   </details> 
 
   
## :bookmark: Day 11 
### :bulb: Theory - Introduction to Baby SoC

<details><summary> Baby SoC </summary>

## **What is SoC (System on Chip)**
* SoC is a single die chip that has some different IP cores on it.
* Based on requirement, it may integrated components that contain analog or digital processing system, mixed signal or a floating point unit that all lying on a single chip substrate. 
* Soc is widely used in electronics industry due to its low power consumption, small die area and also having embedded system with equivalent functionality.
 
## **SoC Structure**
![SoC block diagram example](https://user-images.githubusercontent.com/62828746/210885173-a92b7101-89a0-4e5f-82a1-782d4b8ccaad.png)

**SoC consists of:**
**Elements**      | **Function**      | **Example**
---------------   | ---------------   | --------------- 
Hardware Functional Unit | Consists of microprocessors responsible for memory, running code, and digital signal processors | Processor Cores, Memory, Interfaces, Digital Signal Processor (DSP)
Intermodule Communication | Connect, control, direct and interface between functional modules | Bus-BasedCommunication, Networkonachip
 
**SoC vs CPU**
* In older day CPU are the primary processor and the most significant part inside the computing system.
* Nowadays, SoC integrate the power of CPU with others components while CPU is only part of the structure that eventually became an add-ups for SoC.
 
## **Types of SoC**
Qualcomm’s Snapdragon processors are one of the the most ubiquitous SoCs in the Android smartphone space. 
![snapdragon_s600](https://user-images.githubusercontent.com/62828746/210879205-12bd3c03-64e3-4356-8b4d-9ae6dc5ca98e.png)
*Source:[Qualcomm Snapdragon 600 APQ8064T](https://www.notebookcheck.net/Qualcomm-Snapdragon-600-SoC.90004.0.html)*
 
* **Qualcomm Snapdragon 600 APQ8064T** is a high-end SoC for mostly Android based smartphones and tablets that was announced at the beginning of 2013. 

![snapdragon gen8](https://user-images.githubusercontent.com/62828746/210879212-f05cb47a-ae97-477e-8760-65320a44ea8a.png)
*Source:[Qualcomm Unveils Snapdragon 8 Gen 2 Mobile Platform With Faster, More Intelligent Everything](https://hothardware.com/news/qualcomm-unveils-the-snapdragon-8-gen-2-with-faster-everything)*
 
* **Qualcomm Snapdragon 8 Gen 2 Mobile Platform** is a high-end SoC for smartphones that was introduced in late 2022 and manufactured in 4 nm at TSMC (N4P).
* Compared to Snapdragon 600 which has 28nm manufacturing technology, it was manufactured in only 4nm which is way smaller.
+ New improvement in tech:
  *  Adreno 740 GPU: support Hardware Raytracing and tops even the iGPU in the Apple A16.
  *  FastConnect 7800 modem: support Wi-Fi 7 and Bluetooth 5.3
 
## **Introduction to VSDBabySoC**
 ![vsdbabysoc_block_diagram](https://user-images.githubusercontent.com/62828746/210886623-b846ba0d-bc77-442e-8c69-c2083579a769.png)
*Source[VSDBabySoC Block Diagram](https://github.com/manili/VSDBabySoC#problem-statement)
 
* **VSDBabySoC** is a small yet powerful RISCV-based SoC. 
* The main purpose of designing such a small SoC is to test three open-source IP cores together for the first time and calibrate the analog part of it. 
+ Three open-source IP cores:
  * RVMYTH microprocessor
  * 8x-PLL to generate a stable clock
  * 10-bit DAC to communicate with other analog devices

## **What is RVMYTH**
* **RVMYTH core:** a simple RISCV-based CPU, introduced in a workshop by RedwoodEDA and VSD. 
* **RISC-V ("risk five"):** is an open standard instruction set architecture (ISA) based on Reduced Instruction Set Computer (RISC) principles. 
 
## **What is PLL**
![PLL](https://user-images.githubusercontent.com/62828746/210892591-b59a049f-a23b-491c-8bf2-8d1518f487ba.jpg)
* **PLL (phase-locked loop):** a control system that generates an output signal whose phase is related to the phase of an input signal. 
* PLLs are widely used for synchronization purposes, including clock generation and distribution.
* **Phase detector:** compares the input frequency (Fref) with the feedback frequency and generate output signal (dc voltage) which is a function of the difference between the phases of the two input signals. 
* **Low pass filter:** Remove high frequency noise from the dc voltage. (generated bt phase detector)
* **Voltage Controlled Oscillator (VCO):** is the circuit block that generates the radio frequency signal that is normally considered as the output of the loop. 
 
## **What is DAC**
![dac](https://user-images.githubusercontent.com/62828746/210892588-10d1f028-9e0a-4fd4-b28e-43823df76b9d.jpg)
* **DAC (Digital-to-analog converter): a system that converts a digital signal into an analog signal. 
* DACs are widely used in modern communication systems enabling the generation of digitally-defined transmission signals. 
* As a result, high-speed DACs are used for mobile communications and ultra-high-speed DACs are employed in optical communications systems.
 
## **Introduction to VSDBabySoC Modelling**
 
**Summary steps of VSDBabySoC Modelling:**
![VSDBabySoC Modeling](https://user-images.githubusercontent.com/62828746/210895183-df0d71f9-cdc5-43c0-8125-c8e2ef53cfd5.png)
 
* VSDBabySoC will be modelled and simulated the using **iverilog**.
+ To model VSDBabySoC, need to have:
  * 3 main elements (IP cores) 
  * a wrapper as an SoC
  * testbench module
 
 
   </details> 



## :bookmark: Day 12
### :bulb: Theory - BabySoC Modelling

<details><summary> BabySoC Modelling </summary>

## **What is Modelling**

* HDL (Hardware Description Language) are used to describe the model of a digital hardware. 
* The model of a digital hardware gives the external view and one or more internal views.
* Internal View: Gives the functionality of the structure.
* External view: Gives the interface of the device.
* Modeling and simulation is the use of a physical or logical representation of a given system to generate data and help determine decisions or make predictions about the system.
* The fundamental goal in modeling : to obtain the functional relationship among the terminal electrical variables of the device that is to be modeled.
 
**Modeling Styles**      | **Function**      
---------------------    | ---------------
Gate-Level | Used to model combinatorial circuits 
Data Flow | Used to model combinatorial circuits 
Behavioral | Used for both combinatorial and sequential circuits.

 
## **RVMYTH modelling**
* RVMYTH core: a simple RISCV-based CPU, introduced in a workshop by RedwoodEDA and VSD.
* Basic RISC-V CPU micro-architecture is designed with 3 stages fetch, decode and execute based on RISC-V ISA.
+ Fetch: 
  * During Fetch Stage, processor fetches the instruction from the IM pointed by address given by PC..
  * Program Counter (PC): Holds the address of next Instruction
  * Instruction Memory (IM): Holds the set of instructions to be executed
+ Decode:
  * During Decode Stage, processor decodes the instruction based on instruction format and type of instruction.
  * Instruction Format includes Opcode, immediate value, source address, destination address. 
  * 6-types of instruction: </br>
    R-type - Register </br>
    I-type - Immediate </br>
    S-type - Store </br>
    B-type - Branch (Conditional Jump) </br>
    U-type - Upper Immediate </br>
    J-type - Jump (Unconditional Jump) </br>
+ Register File Read and Write:
  * Register file is 2 read, 1 write means 2 read and 1 write operation can happen simultanously.
  * Inputs: </br>
    Read_Enable - Enable signal to perform read operation </br>
    Read_Address1 - Address1 from where data has to be read </br>
    Read_Address2 - Address2 from where data has to be read </br>
    Write_Enable - Enable signal to perform write operation </br>
    Write_Address - Address where data has to be written </br>
    Write_Data - Data to be written at Write_Address </br>
   * Outputs: </br>
    Read_Data1 - Data from Read_Address1 </br>
    Read_Data2 - Data from Read_Address2 </br>
+ Execute:   
  * During the Execute Stage, both the operands perform the operation based on Opcode.
+ Control Logic:
  * During Decode Stage, branch target address is calculated and fed into PC mux. 
  * Before Execute Stage, once the operands are ready branch condition is checked.
 
## **PLL modelling**
![PLL](https://user-images.githubusercontent.com/62828746/210899176-c5868e2c-2f43-424e-8c56-fc2cdaabd45e.jpg)
 
* Phase-locked loop (PLL) is an electronic circuit with a voltage or voltage-driven oscillator that constantly adjusts to match the frequency of an input signal.
+ Design trade-off of PLL: frequency bandwidth response will defines the jitter response.
  * Lower frequency bandwidth = lower sensitivity to jitter in the reference clock input.
  * Lower frequency bandwidth = lower the sensitivity to VCO jitter.
 
**How is clock generated?**
* By using Quartz crystal oscillator.
+ While to generate high-frequency clocks on-chip, using one of two main circuit:
  * Phase-Locked Loop (PLL)
  * Delay-Locked Loop (DLL)
* Clock might have clock jitter or delay due to long wire. 
* Hence, concept of ppm(clock accuracy) comes in, when ever quartz is acquired, it comes with a zero or small ppm error.

**PPM error**
![Ppm calculation](https://user-images.githubusercontent.com/62828746/210901686-6030849d-d5c0-41d1-b636-777cb1ab0177.jpg)
 * PPM (Parts per million): a measurement used today by many customers to measure quality performance.
 * One PPM means one (defect or event) in a million or 1/1,000,000
 
 
 ## **DAC modelling**
 
![dac](https://user-images.githubusercontent.com/62828746/210899171-0b42fd14-7750-4046-9f18-86b12e6883d5.jpg)
![repo dac](https://user-images.githubusercontent.com/62828746/211184883-1c014b4f-e9a1-46e4-8453-8f0f1425f388.png)
*Source:[SoC design using RISC-V based core and 10-bit DAC Sky130 IP](https://github.com/vsdip/rvmyth_avsddac_interface)*
* Above is the example of integration of (RISC-V) with digital to analog converter (DAC) and perform PNR using end-to-end open-source EDA tools. 
* First, we will need to generate a verilog module for DAC and obtain the analog output reciprocation for some arbitrary digital inputs to test it. 
* Later we will give the digital output of rvmyth to the 10-bit DAC by creating an interface between the two analog and digital blocks.
 
## **Simulating using VCS**

* We using VCS to simulate three cores inside VSDBabySoC after modelling them usign Verilog.
* **VCS**: is a high-performance, high-capacity Verilog simulator that incorporates advanced, high-level abstraction verification technologies into a single open native platform. 
 
![vcs steps](https://user-images.githubusercontent.com/62828746/211151899-f226cb76-9d5e-40df-b94e-c4913e22b319.jpg)
* **Modelling** - Using HDL to design a block's verilog file which met it's functionality and a testbench to check its functionality.
* **Compilation** - VCS builds the instance hierarchy and generates a binary executable simv. This binary executable is later used for simulation.
* **Simulation**  - During compilation, VCS generates a binary executable, simv. You can use simv to run the simulation.
+ There are 2 types mainly - 
  * Interactive mode (debug the design but compilation will not be optimized.)
  * Batch mode

 
**Run type**      | **Option and function**
----------------  | -----------------------  
VCS | -debug : Enables DVE and UCLI debugging. </br> -debug_all : Enables DVE and UCLI debugging inluding line stepping. </br> -h or -help : Lists descriptions of the most commonly used VCS compile and runtime options. </br> -sverilog : Enables the etensions to the Verilog language in the Accellera SystemVerilog specification. </br> +debug_all : Enables you to use the OpenVera testbench GUI. </br> -full64 : Enables compilation and simulation in 64 bit mode, see “Optimizations To Reduce Memory Consumption” </br> +race : Specifies that during simulation VCS generate a report of all the race conditions in the design and write this report in the race.out file.
DVE | -gui : Invokes DVE at runtime.  </br> -ucli : Invokes the UCLI debugger command line if issued at runtime. </br>  -i inputFilename : Reads interactive commands from a file, then switches to reading from standard command line input. </br> -k keyFilename : Writes interactive commands entered to keyFilename, which can be used by a later simv as -i inputFilename </br> -l logFilename : Captures simulation output, such as user input commands and responses to UCLI commands.

 
## **Tips for modelling a design**
**Techniques**      | **Description**      | **Example**
-----------   | --------------  | ------------- 
Avoid race Conditions | A race condition is defined as a coding style for which there is more than one correct result. </br> Can be detected using race detection tool | two parallel blocks have no guaranteed ordering, so it is ambiguous whether the $display statement will be executed </br> ![race condition](https://user-images.githubusercontent.com/62828746/211152680-92ec5d55-a6b5-40c9-a865-66fd063164dc.jpg)
Use a optimized Testbench for debugging your design | Using optimized testbenches by executing/enabling debugging features that are selective. | Use ‘ifdef, ‘else, and ‘endif compiler directives in your testbench to specify compiling certain system tasks for debugging features when the +define compile-time option is on the command line </br> ![Optimizing Testbenches ](https://user-images.githubusercontent.com/62828746/211153368-674e1eaa-5fd6-42af-b0bb-8b91d65df8a3.jpg)
Creating models that simulate faster | Use higher level abstraction when modelling design.Behavioral and RTL models simulate much faster that gate and switch level models. This rule of thumb applies to all Verilog simulators and even all logic simulator. | ![Creating Models That Simulate Faster](https://user-images.githubusercontent.com/62828746/211153932-d0437814-a40b-4ae3-83ea-471dc6d6f0f2.jpg)
Case statement behaviour | In VCS,  z does not stand for don’t care in a case statement, like it does in a casez or casex statement. In a case statement z stands for the usual high impedance and therefore so will ? | </br> 
 

   </details> 
 
 
### :pencil2: Lab Topic - VSDbabySoC Modelling
<details><summary>  RVMYTH modelling  </summary>
 
### Lab -  RVMYTH modelling 
 
#### Steps:
> 1. Copy required file (verilog and testbench), compile and simulate code and generate vcd file.
>> *git clone https://github.com/kunalg123/rvmyth/*
>> *cd rvmyth*
>> *csh*
>> *vcs mythcore_test.v tb_mythcore_test.v*
>> *./simv*
>> *dve -full64 &*
> 2. Go to file/File/Open Database” and select the “.vcd” file from the project folder
> 3. Add the required waveforms. 

#### Result:
![RVMYTH modelling_0](https://user-images.githubusercontent.com/62828746/211184657-3cc47208-0998-4867-b961-6448d4c1d52e.png)
![RVMYTH modelling_1](https://user-images.githubusercontent.com/62828746/211184658-b58a394d-9193-478e-b963-17e304f45b90.png)
![RVMYTH modelling_2](https://user-images.githubusercontent.com/62828746/211184659-776d8aa7-954e-4faf-9d59-de4ad7f90c04.png)
 
   </details> 


<details><summary>  DAC modelling  </summary>
 
### Lab -  DAC modelling 
 
#### Steps:
> 1. Compile and simulate code and generate vcd file.
>> *cd rvmyth*
>> *csh*
>> *vcs avsddac.v  avsddac_tb_test.v*
>> *./simv*
>> *dve -full64 &*
> 2. Go to file/File/Open Database” and select the “.vcd” file from the project folder
> 3. Add the required waveform.
 
#### Result:
![DAC modelling_0](https://user-images.githubusercontent.com/62828746/211184675-53671c65-7443-452d-8af9-47dcdf975e8d.png)
![DAC modelling_1](https://user-images.githubusercontent.com/62828746/211184676-84ab17a5-668d-4523-a9ff-9db32e835f09.png)
![DAC modelling_2](https://user-images.githubusercontent.com/62828746/211184677-0aa9f32f-549d-4122-acb2-bbefc59739f3.png)
![DAC modelling_3](https://user-images.githubusercontent.com/62828746/211184678-4c8efc5e-a7aa-423d-8294-a40c9ce10029.png)
![DAC modelling_4](https://user-images.githubusercontent.com/62828746/211184679-b35f7406-4a9f-4777-ba8c-ee11fd0579ca.png)
![DAC modelling_5](https://user-images.githubusercontent.com/62828746/211184681-a39e5dd3-f40c-411e-baff-441a8e23cb2d.png)
  
   </details> 


<details><summary>  PLL modelling  </summary>
 
### Lab -  PLL modelling 
 
#### Steps:
> 1. Compile and simulate code and generate vcd file.
>> *cd rvmyth*
>> *csh*
>> *vcs avsd_pll_1v8.v pll_tb.v*
>> *./simv*
>> *dve -full64 &*
> 2. Go to file/File/Open Database” and select the “.vcd” file from the project folder
> 3. Add the required waveform
 
#### Result:
![PLL modelling_0](https://user-images.githubusercontent.com/62828746/211184683-d3c816e6-5790-4eab-9a92-34d5bd5b6c50.png)
![pll](https://user-images.githubusercontent.com/62828746/211184765-7cfe7862-9909-4440-a253-b1c060f7be79.png)
*Source:[RISC-V based SOC Design with PLL using Open-Source EDA Tools](https://github.com/vsdip/rvmyth_avsdpll_interface)*
![PLL modelling_1](https://user-images.githubusercontent.com/62828746/211184685-41047239-da5e-444c-b201-27516f6400c4.png)
![PLL modelling_2](https://user-images.githubusercontent.com/62828746/211184686-e62f8a28-60fd-49f9-ba1a-21bef2d83a26.png)
 
   </details> 


<details><summary>  RVMYTH_PLL modelling  </summary>
 
### Lab -  RVMYTH_PLL modelling 
 
#### Steps:
> 1. Compile and simulate code and generate vcd file.
>> *cd rvmyth*
>> *csh*
>> *vcs rvmyth_pll.v rvmyth_pll_tb.v*
>> *./simv*
>> *dve -full64 &*
> 2. Go to file/File/Open Database” and select the “.vcd” file from the project folder
> 3. Add the required waveform
 
#### Result:
![RVMYTH_PLL modelling_0](https://user-images.githubusercontent.com/62828746/211184664-ee0ba325-5abd-4e72-bfca-55cd271566c1.png)
![RVMYTH_PLL modelling_1](https://user-images.githubusercontent.com/62828746/211184665-02277b90-9e6d-4b6f-942d-64e330576ef9.png)
![RVMYTH_PLL modelling_2](https://user-images.githubusercontent.com/62828746/211184666-8e3a68fa-0a5f-4cb2-98e1-e283a310af97.png)
 
   </details> 


<details><summary>  RVMYTH_DAC modelling  </summary>
 
### Lab -  RVMYTH_DAC modelling 
 
#### Steps:
> 1. Compile and simulate code and generate vcd file.
>> *cd rvmyth*
>> *csh*
>> *vcs -sverilog rvmyth_avsddac.v rvmyth_avsddac_TB.v*
>> *./simv*
>> *dve -full64 &*
> 2. Go to file/File/Open Database” and select the “.vcd” file from the project folder
> 3. Add the required waveform
 
#### Result:
![RVMYTH_DAC modelling_0](https://user-images.githubusercontent.com/62828746/211184660-80db86ec-2bf4-410c-a11e-4eb0c9598d80.png)
![RVMYTH_DAC modelling_1](https://user-images.githubusercontent.com/62828746/211184661-cfb45ccb-1fe3-4670-9411-1f3f38b52858.png)
![RVMYTH_DAC modelling_2](https://user-images.githubusercontent.com/62828746/211184662-4fff5022-201c-4344-bcee-19ed135cf791.png)
![RVMYTH_DAC modelling_3](https://user-images.githubusercontent.com/62828746/211184663-94415228-0b57-4097-804e-9ff44d87fa62.png)
 
   </details> 

<details><summary>  VSDBabySoC modelling  </summary>
 
### Lab -  VSDBabySoC modelling 
 
#### Steps:
> 1. Compile and simulate code and generate vcd file.
>> *cd rvmyth*
>> *csh*
>> *vcs vsdbabysoc.v testbench.v*
>> *./simv*
>> *dve -full64 &*
> 2. Go to file/File/Open Database” and select the “.vcd” file from the project folder
> 3. Add the required waveform
 
#### Result:
![VSDBabySoC modelling_0](https://user-images.githubusercontent.com/62828746/211184667-5dabfc70-7b1b-4ee5-8f2c-f295d0cd44ea.png)
![VSDBabySoC modelling_1](https://user-images.githubusercontent.com/62828746/211184668-46449519-0720-41dc-9e1a-16d772e12d07.png)
![VSDBabySoC modelling_2](https://user-images.githubusercontent.com/62828746/211184669-18202f1c-3416-468f-8eab-1aab3dc9548e.png)
 
   </details> 

<details><summary>  Differences in Interactive Mode  </summary>
 
### Lab -  Differences in Interactive Mode 
 
**Option**      | **Description**    | **Example**
--------------  | ------------------ | ------------------
-debug  | Enables DVE and command line debugging option. This option does not enable line stepping | </br>
-debug_all | Enables command line debugging option including line stepping | </br>
-debug-pp | Creates a VPD file (when used with the VCS system task $vcdpluson) and enables DVE for post-processing a design. </br> Using -debug-pp can save compilation time by eliminating the overhead of compiling with -debug and -debug_all.
-debug_access | Enables dumping to FSDB/VPD, and limited read/callback capability. | Use'-debug_access+class' for testbench debugging. </br> Use'-debug_access+designer' to enable debug capability commonly used by DUT designers. </br> Use'-debug_access+simctrl' to enable debug capability needed by UCLI to control the simulation. </br> Use'-debug_access+all' to enable all debug capability.
-debug_region* |  Controls what regions in the design debug capability (specified by -debug_access*) gets added. | </br>
-debug_report<+debug.report> | Generates a debug.report file containing a list of where all the  debug capability added to the design came from. | </br>

   </details> 
   
<details><summary>  4-bit Adder by using Full Adder   </summary>
 
### Lab -  4-bit Adder by using Full Adder 
 
#### Steps:
> 1. Compile and simulate code and generate vcd file.
>> *cd rvmyth*
>> *csh*
>> *vcs -sverilog full_adder.v full_adder_tb.v*
>> *./simv*
>> *dve -full64 &*
> 2. Go to file/File/Open Database” and select the “.vcd” file from the project folder
> 3. Add the required waveform
 
#### Result:
![4-bit Adder by using Full Adder_0](https://user-images.githubusercontent.com/62828746/211184674-aaa675ac-66e9-4ae2-98d5-d8ab827929ad.png)
![4-bit Adder by using Full Adder](https://user-images.githubusercontent.com/62828746/211184671-217d95aa-3de0-4f81-af59-9605c92b7fd0.png)


   </details> 
   

## :bookmark: Day 13
### :bulb: Theory - Post-synthesis simulation

<details><summary> Post-synthesis simulation </summary>

## **Pre-synthesis VS Post-synthesis**
* Simulation is the process of verifying the functionality and timing of a design against its original specifications. 
Both pre-synthesis and post-synthesis simulation are using same language.
The difference is indeed whether the design needs to be synthesizable.
* Synthesis tool: synopsys’s DC shell(Design Compiler), which enables users to meet today's design challenges with concurrent optimization of timing, area, power and test
 
**Pre-synthesis**             | **Post-synthesis**      
--------------------------    | ------------------ 
Perform functional simulation (RTL Simulation) | Perform gate level simulation based on netlist generated by synthesis. (GLS Simulation)
Order of blocking assignments can matter | Order of blocking assignments does not matter
Verify logical functionality of design, did not concern specific timing details | Verify both logical functionality and timing
Assumes ideal hardware, zero delay environment | Considering each gate delays and timing constraints into account, can be zero delay also
Saves time, since don't need to wait for the synthesis process before simulating again after making a change | Relatively more time and effort to get useful results
Pre-layout netlist - Consists of the information of gate to gate connections according to the logic | Post-layout netlist - cnsists of the gate to gate, pin to pin connection of each gate and IP models including buffers
To simulate abd debug design functionality in earlier stage. | To boost the confidence regarding implementation of a design and can help verify dynamic circuit behaviour, which cannot be verified accurately by static methods.
Do not takes the synthesized input as netlist| Takes the synthesized input as netlist
 
 
## **The list of synthesizable and non-synthesizable Verilog constructs**
![synthesizable and non- synthesizable constructs_0](https://user-images.githubusercontent.com/62828746/211261371-46aaa4c4-4f59-4079-adbe-429a179cfd3b.png)
![synthesizable and non- synthesizable constructs_1](https://user-images.githubusercontent.com/62828746/211261373-c28bd16c-5d88-4dd2-847f-0a065ba0922f.png)

 *Source: [Synthesizable and Non-Synthesizable Verilog Constructs](https://link.springer.com/content/pdf/bbm:978-81-322-2791-5/1.pdf)*
  
   </details> 
 
### :pencil2: Lab Topic - RVMYTH-AVSDDAC Pre-synthesis and Post-synthesis simulation
<details><summary>  Lab - RVMYTH-AVSDDAC Pre-synthesis and Post-synthesis  </summary>
 
#### Steps:
> 1. Convert .lib to .dc
>> lc_shell </br>
>> read_lib sky130_fd_sc_hd__tt_025C_1v80.lib </br>
>> write_lib sky130_fd_sc_hd__tt_025C_1v80 -format db -output library.db </br>
>> read_lib avsddac.lib </br>
>> write_lib avsddac -format db -output avsddac.db </br>
>> read_lib avsd_pll_1v8.lib </br>
>> write_lib avsd_pll_1v8 -format db -output avsd_pll_1v8.db </br>
>> quit </br>
> 2.Invoke dc
>> csh -> to enable c shell dc_shell -> invoke dc compiler </br>
>> dc_shell </br>

#### Result:
![rvmyth_avsddac_0](https://user-images.githubusercontent.com/62828746/211375020-b780911d-fb9f-4df1-acc2-33dd63c832d7.png)

> 3. Read rvmyth_avsddac verilog file using command.
>> ~~read_verilog rvmyth_avsddac.v~~ </br
>> read_file {rvmyth_avsddac.v avsddac.v mythcore_test.v clk_gate.v} -autoread -format verilog -top rvmyth_avsddac </br
>> source /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/setup_lib.tcl </br>
>> link </br>
>> compile </br>
>> check_timing </br>
>> report_timing </br>
>> report_constraint </br>
>> report_constraint -all_violators </br>
>> report_clocks </br>
>> check_area </br>
>> write -f verilog -out rvmyth_avsddac_net.v  </br>

#### Result:
![rvmyth_avsddac_1](https://user-images.githubusercontent.com/62828746/211375025-7bee4141-f04c-45b8-92e7-fe94a8e8cce4.png)
![rvmyth_avsddac_script](https://user-images.githubusercontent.com/62828746/211441127-c5c81334-cb07-4f7e-856a-44ab216d7cb9.png)
![rvmyth_avsddac_3](https://user-images.githubusercontent.com/62828746/211440286-e67b5300-4515-4b69-8c54-c8c12e6dc887.png)
![rvmyth_avsddac_4](https://user-images.githubusercontent.com/62828746/211440290-ca40bfd7-04dc-4504-b7ca-913f7abb284d.png)
![rvmyth_avsddac_5](https://user-images.githubusercontent.com/62828746/211440291-9e52236d-568d-4d48-8bb9-6d2963a8e7e4.png)
![rvmyth_avsddac_6](https://user-images.githubusercontent.com/62828746/211440298-c09792cd-6e0e-4392-a3cd-f765e09956fd.png)
![rvmyth_avsddac_7](https://user-images.githubusercontent.com/62828746/211440300-1bdbf376-13c1-4da9-aade-9eccc0ddfd40.png)
![rvmyth_avsddac_8](https://user-images.githubusercontent.com/62828746/211440302-c7a2986a-a3df-43e6-aadc-f34df93a496e.png)


> 4. Read rvmyth_pll verilog file using command.
>> ~~read_verilog rvmyth_pll.v </br>~~  </br>
>> read_file {avsd_pll_1v8.v mythcore_test.v clk_gate.v rvmyth_pll.v } -autoread -format verilog -top rvmyth_pll_interface
>> source /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/setup_lib.tcl </br>
>> link </br>
>> compile </br>
>> check_timing </br>
>> report_timing </br>
>> report_constraint </br>
>> report_constraint -all_violators </br>
>> report_clocks </br>
>> check_area </br>
>> write -f verilog -out rvmyth_pll_net.v  </br>

#### Result:
![rvmyth_pll_0](https://user-images.githubusercontent.com/62828746/211440305-9ef8d005-c035-47b4-a1b1-c2a5e203880a.png)
![rvmyth_pll_1](https://user-images.githubusercontent.com/62828746/211440308-eaa32226-c7a6-46a2-b5c4-4ba3941d79c9.png)
![rvmyth_pll_2](https://user-images.githubusercontent.com/62828746/211440309-be9a3efa-31ca-4df6-9da4-846d81f89fde.png)
![rvmyth_pll_3](https://user-images.githubusercontent.com/62828746/211949063-0fcb7770-4ad9-48ac-ae7f-8721e46cc2bd.png)
![rvmyth_pll_4](https://user-images.githubusercontent.com/62828746/211949069-cc557c14-d60e-41cc-8652-d20d3ee04b12.png)
![rvmyth_pll_5](https://user-images.githubusercontent.com/62828746/211949071-61b34c15-871a-4280-9c9f-d9d3ec5eab4f.png)
![rvmyth_pll_6](https://user-images.githubusercontent.com/62828746/211949074-99a9558d-9d13-473e-a77c-da854eae17a8.png)
![rvmyth_pll_7](https://user-images.githubusercontent.com/62828746/211949075-d8d3427b-23d9-424d-8e7c-a6d9bb3f760e.png)

> 5. Read vsdbabysoc verilog file using command.
>> ~~read_verilog vsdbabysoc.v~~ </br>
>> read_file { mythcore_test.v avsd_pll_1v8.v avsddac.v clk_gate.v vsdbabysoc.v} -autoread -format verilog -top vsdbabysoc </br>
>> source /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/setup_lib.tcl </br>
>> link </br>
>> compile </br>
>> check_design </br>
>> report_timing </br>
>> report_constraint </br>
>> report_constraint -all_violators </br>
>> report_clocks </br>
>> report_area </br>
>> write -f verilog -out vsdbabysoc_net.v  </br>

#### Result:
![vsdbabysoc_0](https://user-images.githubusercontent.com/62828746/211949076-ac0df80b-4cf8-4c8d-91ad-bb406bb5ac2b.png)
![vsdbabysoc_1](https://user-images.githubusercontent.com/62828746/211949079-c76a9661-0980-437e-b3a4-b05e573d19b0.png)
![vsdbabysoc_2](https://user-images.githubusercontent.com/62828746/211949081-07db8910-770a-44d0-9703-3e97f283126b.png)
![vsdbabysoc_3](https://user-images.githubusercontent.com/62828746/211949083-7282013c-0c85-4614-a07f-afec8abb6ba6.png)
![vsdbabysoc_4](https://user-images.githubusercontent.com/62828746/211949084-bbd7dac0-a2f7-4a0f-82ad-f0537b42dba3.png)
![vsdbabysoc_5](https://user-images.githubusercontent.com/62828746/211949086-2e142785-20a5-492b-846e-b6e460838b77.png)

> 6. Set constraint to vsdbabysoc and optmize it.
>> write -f ddc -out vsdbabysoc_net.ddc </br>
> Launch design vision
>> csh design_vision </br>
> In invoked design vision gui, use command to read ddc file.
>> read_ddc vsdbabysoc_net.ddc
> Review design schematic, create clock, set IO constraint and load.
>> source vsdbabysoc_cons.tcl
>> report_timing </br>
>> report_constraint </br>
>> report_constraint -all_violators </br>
>> report_clocks </br>
>> report_area </br>
>> write -f verilog -out vsdbabysoc_net_cons.v  </br>

#### Result:
![vsdbabysoc_opt0](https://user-images.githubusercontent.com/62828746/211949087-a7607aab-494d-408b-886a-d4dbcbd3c576.png)
![vsdbabysoc_opt1](https://user-images.githubusercontent.com/62828746/211949088-6083a3ea-7254-43ca-8f40-51ab5acf2df9.png)
![vsdbabysoc_opt2](https://user-images.githubusercontent.com/62828746/211949089-dd0ac230-b82a-45d6-82f2-dcc016bc33d0.png)
![vsdbabysoc_opt3](https://user-images.githubusercontent.com/62828746/211949090-1f38c3c0-c877-442b-8339-bfeca0cd6160.png)
![vsdbabysoc_opt4](https://user-images.githubusercontent.com/62828746/211949091-affefa1b-65ae-46a3-86b5-6069559abbb7.png)
![vsdbabysoc_opt5](https://user-images.githubusercontent.com/62828746/211949094-f38d5353-b624-41f9-9ada-3f3972d7a6e5.png)
![vsdbabysoc_opt6](https://user-images.githubusercontent.com/62828746/211949097-2348dc8b-1b2b-4673-92de-e9942d3143ca.png)
![vsdbabysoc_opt7](https://user-images.githubusercontent.com/62828746/211949100-19407e96-53ae-44d7-986f-067ca2e5e31c.png)
![vsdbabysoc_opt8](https://user-images.githubusercontent.com/62828746/211949101-d9668c63-4440-4b09-b4c3-cbc9eda0559a.png)
![vsdbabysoc_opt9](https://user-images.githubusercontent.com/62828746/211949104-6c7574eb-89ca-4ea1-9fc8-278df73356c0.png)
![vsdbabysoc_opt10](https://user-images.githubusercontent.com/62828746/211949108-1f642f33-2445-4b5f-a6e3-0ba436465d17.png)


> 7. Run simulation
>> *csh* </br>
>> *vcs  gls.v sky130_fd_sc_hd.v primitives.v * </br>
>> *./simv* </br>
>> *dve -full64 &* </br>
> 2. Go to file/File/Open Database” and select the “.vcd” file from the project folder
> 3. Add the required waveforms. 
> 4. Add the required waveforms. 
>> *iverilog -o gls.v sky130_fd_sc_hd.v primitives.v*
>> *./a.out*
>> *gtkwave gls.vcd*
> 5.Back to vnc load pre-synthesis simulations waveform generated in previous lab.

#### Result:
![Run simulation_0](https://user-images.githubusercontent.com/62828746/212596121-cb3b5544-0e58-4a0e-914b-511b01e434d1.png)
![Run simulation_1](https://user-images.githubusercontent.com/62828746/212596125-af8b4fdc-dfc4-4647-9360-d204f2ddf744.png)
![Run simulation_2](https://user-images.githubusercontent.com/62828746/212596126-25af1f32-284f-451d-913a-ad749d62c1b8.png)
![Run simulation_3](https://user-images.githubusercontent.com/62828746/212596127-cebe939e-a33d-421b-acf8-8fac8b8cdbe7.png)
![Run simulation_4](https://user-images.githubusercontent.com/62828746/212596128-c53c948b-8e7d-4a0e-b11e-3f2f6a67a524.png)
![Run simulation_5](https://user-images.githubusercontent.com/62828746/212596130-d89a8698-85dc-41f4-a4c6-49b76947c1e3.png)
![Run simulation_6](https://user-images.githubusercontent.com/62828746/212596132-ca9910d3-d0f7-4995-80b0-529c8df1ea1d.png)
![Run simulation_7](https://user-images.githubusercontent.com/62828746/212596134-78508bef-3d8f-40b3-a72f-bc28c7115211.png)
![Run simulation_8](https://user-images.githubusercontent.com/62828746/212596135-9f9c0bdc-c0c0-4dee-ac8a-7ee44da5a92a.png)
![Run simulation_9](https://user-images.githubusercontent.com/62828746/212596136-f48dd3dc-516f-45f4-a12e-da7cf5bdc023.png)
![Run simulation_10](https://user-images.githubusercontent.com/62828746/212596139-2214ed23-6c6c-45ad-b8d4-e0c1469d5250.png)
![Run simulation_11](https://user-images.githubusercontent.com/62828746/212596141-e152c295-41fb-4f9b-be71-c3b4bb08eb54.png)
  
   </details> 
 

## :bookmark: Day 14
### :bulb: Theory -  Synopsys DC and timing analysis 

<details><summary> PVT </summary>
 
## **PVT**
* Cells behavior strongly depends on factors such as PVT, input signals and output load.
* To make fabricated chips working in all possible condition, stimulate it at different corners of process, voltage and temperature.
* While looking at best and worst PVT conditions allows us to predict lower and upper limitation of cell bahvior which are important to ensure the overall functionality of the design.
* **Worst PVT**: Process - Worst | Voltage - Min | Temperature - Max
* **Best PVT**: Process - Best | Voltage - Max | Temperature - Min
* **Worst Cold PVT**: Process - Worst | Voltage - Min | Temperature - Min
* **Best Hot PVT**: Process - Best | Voltage - Max | Temperature - Max
 
P (Process)                                      | V (Voltage)                                    | T (Temperature)
---------------------------------------------    | ---------------------------------------------  | --------------------------------------------- 
Different task or die area (center/boundary) has different process variation during fabrication </br> ![power](https://user-images.githubusercontent.com/62828746/211880506-dc9fd8fc-f2b1-4597-afa3-415c9acb8271.png) | IR drop or supply noise might cause voltage variation. Even supplied voltage might not be stable all the time </br> ![voltage](https://user-images.githubusercontent.com/62828746/211880515-c1a072d8-a50c-41e8-8468-c87139d0ad64.png) |  Density of transistor is inconsistent throughout the chip and resulting in power dissipation and temperature variation across the chip </br> ![temperature](https://user-images.githubusercontent.com/62828746/211952498-5c79f5b1-e3cc-4667-b3ab-ab3730fe0a7e.png)



  </details>

<details><summary> WNS,TNS,WHS and THS </summary>
 
## **WNS,TNS,WHS and THS**
 
* Negative values indicates how much the design is missing the timing requirements.
* The values comes with reference to your design timing constraints.
* We need to fix this violations by setting the timing constraints correctly before moving ahead with hardware testing.
 
**Values**             | **Description**      
------------------     | ------------------ 
WNS | Worst Negative Slack
TNS | Total Negative Slack = sum of the negative slack paths
WHS | Worst Hold Slack
THS | Total Hold Slack = sum of the negative hold slack paths
 

   </details> 


### :pencil2: Lab Topic -  PVT Table of Different Lib 
<details><summary>  PVT Table of Different Lib   </summary>
 
### Lab -  PVT Table of Different Lib  
 
#### Steps:
> 1. Copy library file from git clone
>> git clone https://github.com/Geetima2021/vsdpcvrd
> 2. Convert .lib to .db using lc_shell
>> read_lib sky130_fd_sc_hd__ff_100C_1v65.lib </br>
>> write_lib sky130_fd_sc_hd__ff_100C_1v65 -format db -output library.db </br>
> 3. Read vsdbabysoc file, set library in setup_lib.tcl and report_qor after compile design with each library.
>> read_file { mythcore_test.v avsd_pll_1v8.v avsddac.v clk_gate.v vsdbabysoc.v} -autoread -format verilog -top vsdbabysoc </br>
>> source /nfs/png/disks/png_mip_gen6p9ddr_0032/huifente/sd_training/sky130RTLDesignAndSynthesisWorkshop/DC_WORKSHOP/lib/setup_lib.tcl </br>
>> link </br>
>> compile </br>
>> report_qor
 
#### Result:

**lib file**                  | **WNS** | **WHS** | **TNS** | **THS**    
------------------------------| ------- | ------- | ------- | ------- 
sky130_fd_sc_hd__ff_100C_1v65 | 0.29 | 0.15 | 111.75 | 25.01 
sky130_fd_sc_hd__ff_100C_1v95 | 9.32 | 0.13 | 2713.92 | 17.65
sky130_fd_sc_hd__ff_n40C_1v56 | 0.40 | 0.11 | 163.60 | 4.06
sky130_fd_sc_hd__ff_n40C_1v65 | 0.25 | 0.14 | 87.22 | 22.32
sky130_fd_sc_hd__ff_n40C_1v76 | 0.06 | 0.18 | 13.6 | 47.55  --> Best PVT: Fast process, Min temperature, Max voltage
sky130_fd_sc_hd__ss_100C_1v40 | 5.22 | 0 | 2701.12 | 0
sky130_fd_sc_hd__ss_100C_1v60 | 3.16 | 0 | 1626.25 | 0
sky130_fd_sc_hd__ss_n40C_1v28 | 10.84 | 0 | 5837.22 | 0
sky130_fd_sc_hd__ss_n40C_1v35 | 7.32 | 0 | 3884.71 | 0
sky130_fd_sc_hd__ss_n40C_1v40 | 5.56 | 0 | 2968.22 | 0
sky130_fd_sc_hd__ss_n40C_1v44 | 5.11 | 0 | 2602.91 | 0
sky130_fd_sc_hd__ss_n40C_1v76 | 1.60 | 0 | 798.92 | 0
 
![pvt0](https://user-images.githubusercontent.com/62828746/211913254-61f8d932-3f13-4cec-bbc4-191f729bd9f7.png)
![pvt1](https://user-images.githubusercontent.com/62828746/211913262-a37e95bc-75ea-49c3-86bb-fb6e287bf8fe.png)
![pvt2](https://user-images.githubusercontent.com/62828746/211913270-e3a57851-9dbc-4d26-957c-2edbe7a2fc84.png)
![pvt3](https://user-images.githubusercontent.com/62828746/211913275-39b917cd-cab7-4d76-9d33-34c19e1cdbef.png)
![pvt4](https://user-images.githubusercontent.com/62828746/211913278-ecc8a93e-cb1a-4f16-b150-8fe6fc8d49b6.png)
![pvt5](https://user-images.githubusercontent.com/62828746/211913280-1ddeb97e-296a-4358-a6a6-f038986678ad.png)
 
 
   </details>  

## :bookmark: Day 15
### :bulb: Theory - How to talk to computers

<details><summary> How to talk to computers </summary>
 
## **RISC-V Instruction Set**

* **Instruction set: is a group of commands for a central processing unit (CPU) in machine language. It tells the CPU to perform tasks.**
+ Types of instruction sets:
  * **Complex instruction set computer:** CISC processors have an additional microcode or microprogramming layer where instructions act as small programs.
  * **Reduced instruction set computer:** RISC uses a smaller and more compact instruction set with a fixed instruction format. It is designed to process faster and more efficiently.
  * **Enhancement instruction sets:** These instruction types are more familiar because they are often used in marketing CPUs. 

* RISC-V is an open instruction set architecture (ISA). There are a number of companies manufacturing all variants of RISC-V cores in their microcontrollers, microprocessors, and SoCs. 
 
* 1.RISC-V instruction set are translated into machine code.
* 2.Use RTL to implement the RISC-V specification.
* 3.Synthesis the RTL into gate-level netlist.
* 4.Synthesized netlist was then used for physical implementation.

 ## **RISC-V Instruction Set Example**
 
   </details> 
   
### :bulb: Theory - SoC design and OpenLANE

<details><summary> SoC design and OpenLANE </summary>
    
* OpenLane is an automated RTL to GDSII flow based on several components including OpenROAD, Yosys, Magic, Netgen, CVC, SPEF-Extractor, CU-GR, Klayout and a number of custom scripts for design exploration and optimization.  </br>

* The flow performs full ASIC implementation steps from RTL all the way down to GDSII. </br>
![SKY130_D1_SK2 - SoC design and OpenLANE_0](https://user-images.githubusercontent.com/62828746/212574758-0b929d29-090e-4d32-8a66-137f7e6c532c.png)

   </details> 
   
<details><summary> Simplified RTL2GDS Flow </summary>
  
**Simplified RTL2GDS Flow**
![SKY130_D1_SK2 - SoC design and OpenLANE_1](https://user-images.githubusercontent.com/62828746/212574762-e069b4c4-4853-44af-b21c-6cabc01ac652.png)

+ When usign open source need to consider:
  * Tools qualification
  * Tools calibration
  * Missing tools
 
**OpenLane** 
* Main goal: Produce clean (DRC and LVS clean) GDSII with no human intervention (no-human-in-the-loop)
* Tuned for SkyWater 130nm Open PDK
* Can be used to harden (generate GDSII from RTL) macro and chips.
* Operation modes: autonomous or interactive.
* Design space exploration: find the best set of flow configurations automatically 
* Large number of design: 43 designs with their best configuration for now, will be added soon.


![SKY130_D1_SK2 - SoC design and OpenLANE_2](https://user-images.githubusercontent.com/62828746/212574764-f2966929-7cb9-47a7-af30-89be1ac21d42.png)
 
   </details>  
   

### :pencil2: Lab - Get familiar to open-source EDA tools

<details><summary> OpenLANE Directory structure in detail </summary>

#### Steps:
>> *cd /home/huifen.teoh/Desktop/work/tools/openlane_working_dir* </br> 
>> *cd openlane* </br> 
>> *cd pdks* </br> 
  
#### Result: 
![OpenLANE Directory structure in detai_0](https://user-images.githubusercontent.com/62828746/212579482-3ca52333-4e9f-4b59-a130-ce0b14828215.png)

#### Steps:
>> *make mount* -> to invoke OpenLANE </br> 
>> *./flow.tcl -interactive* -> run OpenLANE in interactive mode </br> 
>> *package require openlane 0.9* -> import required package </br> 
>> *prep -design picorv32a* -> prepare deisgn, merge .lef with .tlef* </br> 
#### Result: 
![Review files after design prep and run synthesis_0](https://user-images.githubusercontent.com/62828746/212579488-275b714d-6b6b-4d53-9e1b-33f40f4894dc.png)

## **Review files after design prep and run synthesis**
>> *cd /home/huifen.teoh/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/16-01_00-57*
>> *cd reports/synthesis*
#### Result: 
![Review files after design prep and run synthesis_1](https://user-images.githubusercontent.com/62828746/212579492-d03468e7-20a4-4dea-965b-472876a59dba.png)
![Design Preparation Step_0](https://user-images.githubusercontent.com/62828746/212579494-74c04647-ba30-4609-95fb-31168254d046.png)
![Design Preparation Step_1](https://user-images.githubusercontent.com/62828746/212579495-550debcd-83d3-44ca-b00a-3a62e8075870.png)
![Design Preparation Step_2](https://user-images.githubusercontent.com/62828746/212579498-116902b7-02e7-40c9-8d6a-594b5e5b26e0.png)
   
    
## **OpenLANE Project Git Link Description**

#### Result: 
Github reference for OpenLANE detail:(https://github.com/efabless/OpenLane) </br>
Github reference for OpenLANE design stage detail:(https://github.com/efabless/OpenLane#openlane-design-stages) </br>
Github reference for command used in interactive mode for each stage:(https://github.com/efabless/OpenLane/blob/master/docs/source/advanced_readme.md) </br>
Yotube video can be refered for further information:(https://www.youtube.com/playlist?list=PLUg3wIOWD8yoZCg9XpFSgEgljx6MSdm9L) </br>
 
![fossil dial up](https://user-images.githubusercontent.com/62828746/212581235-c56ee297-d0e6-4c27-b89b-ad4405cc98e5.png)
 
## **Steps to characterize synthesis results**
>> *run_synthesis* </br>
>> *cd /home/huifen.teoh/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/16-01_00-57/reports/synthesis* -> to view report after run synthesis </br>
>> *vim 1-yosys_4.stat.rpt* -> view static report </br>
>> *vim 2-openstat.timing.rpt* -> view timing report </br>
#### Result: 
![SKY_L5 - Steps to characterize synthesis results_0](https://user-images.githubusercontent.com/62828746/212584534-8e9b9579-5cdd-4594-8d3b-8ac23d333acc.png)
![SKY_L5 - Steps to characterize synthesis results_1](https://user-images.githubusercontent.com/62828746/212584535-d0d54584-1ca6-4a87-85b0-ba7f8e14bc1f.png)
![SKY_L5 - Steps to characterize synthesis results_2](https://user-images.githubusercontent.com/62828746/212584538-b52f6174-3822-4178-a73a-bdedc561d4e9.png)
![SKY_L5 - Steps to characterize synthesis results_3](https://user-images.githubusercontent.com/62828746/212584542-ceec1ab4-f2ee-4ef2-98f4-e1e8de55c90f.png)
![SKY_L5 - Steps to characterize synthesis results_4](https://user-images.githubusercontent.com/62828746/212584547-6e3f2e14-5f2d-4f03-9053-1b75c9a1e92a.png)
![SKY_L5 - Steps to characterize synthesis results_5](https://user-images.githubusercontent.com/62828746/212584549-6d6ba18b-174c-4eaa-ba6a-2c997f257915.png)

   </details> 

   
## :bookmark: Day 16  Good floorplan vs bad floorplan and introduction to library cells
### :bulb: Theory - Chip Floor planning considerations

<details><summary> Utilization factor and aspect ratio </summary>
 
 ![image](https://user-images.githubusercontent.com/62828746/215449490-1e6776dc-5ef7-4b24-8a40-803842e21924.png)
 ![image](https://user-images.githubusercontent.com/62828746/215449936-94168ea5-8b9e-4aa7-9ae1-3262ce9fa648.png)

   </details> 

<details><summary> Concept of pre-placed cells </summary>
![image](https://user-images.githubusercontent.com/62828746/215450003-2dccad1c-df4a-494a-8131-00eaa5fd934e.png)
![image](https://user-images.githubusercontent.com/62828746/215450384-fceb1a48-e77b-458b-9573-b289174a48b5.png)
![image](https://user-images.githubusercontent.com/62828746/215450437-2bfe12b5-70b5-4604-af04-c46613fb7d0a.png)

   </details> 
   
<details><summary> De-coupling capacitors </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215450734-cf941de6-fea5-41b9-8d8e-b94204f4c6f3.png)
![image](https://user-images.githubusercontent.com/62828746/215450823-75aea596-dfa0-415c-8d53-a0f4f12979ac.png)
![image](https://user-images.githubusercontent.com/62828746/215450861-f1a2f572-3c68-46bb-8729-5dd09c841b97.png)
![image](https://user-images.githubusercontent.com/62828746/215450916-a392cc4d-eb9c-4c38-94d6-190a8c0c05ab.png)
![image](https://user-images.githubusercontent.com/62828746/215450964-8766fd5b-c869-4cd4-a94e-810b2e555f4d.png)

   </details> 

<details><summary> Power planning </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215451026-0ba04153-722c-4cb4-aaea-f5a54b9fd88c.png)
![image](https://user-images.githubusercontent.com/62828746/215451084-c220c722-5562-43c1-9707-898a6a167692.png)
![image](https://user-images.githubusercontent.com/62828746/215451485-0d89a98e-844e-4e08-9ef1-fbfc36d76976.png)
![image](https://user-images.githubusercontent.com/62828746/215451532-96c50e4f-f52f-406c-b729-8d4efca8aa8e.png)
![image](https://user-images.githubusercontent.com/62828746/215451576-5869000f-a728-4ef7-ba38-e4af6ef9e5c9.png)
![image](https://user-images.githubusercontent.com/62828746/215451633-160e0b01-f2ca-4701-9a1c-080c7f8aa1ad.png)
![image](https://user-images.githubusercontent.com/62828746/215451669-69d32396-b60c-458d-9e56-457283291d92.png)
 
   </details> 
 
<details><summary> Pin placement and logical cell placement blockage </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215451836-18cfa1f8-4170-42a3-b08e-ff6ef4568ce9.png)
![image](https://user-images.githubusercontent.com/62828746/215451868-025d2968-70d9-4fb9-b650-a3a2f252f3bd.png)
![image](https://user-images.githubusercontent.com/62828746/215451911-8c2178ef-bda2-4d32-be67-2d6a52f16bea.png)

<WIP...>
 
   </details> 
   
 
### :bulb: Theory - Library Binding and Placement
 
<details><summary> Netlist binding and initial place design </summary>
 
</details> 
 
<details><summary> Optimize placement using estimated wire-length and capacitance </summary>
 
</details> 
 
<details><summary> Final placement optimization </summary>
 
</details> 
 
<details><summary> Need for libraries and characterization </summary>
 
</details> 
 
<details><summary> Netlist binding and initial place design </summary>
 
</details> 
 
 
### :bulb: Theory - Cell design and characterization flows
 
<details><summary> Inputs for cell design flow </summary>
 
</details> 
 
<details><summary> Circuit design step </summary>
 
</details> 
 
<details><summary> Layout design step </summary>
 
</details> 
 
<details><summary> Typical characterization flow </summary>
 
</details> 
 
 
### :bulb: Theory - General timing characterization parameters
 
<details><summary> Timing threshold definitions </summary>
 
</details> 
 
<details><summary> Propagation delay and transition time </summary>
 
</details> 
 

### :pencil2: Lab - Chip Floor planning considerations

<details><summary> Steps to run floorplan using OpenLANE </summary>

![image](https://user-images.githubusercontent.com/62828746/215453764-aa3794ce-9195-4102-bf34-2033513192ad.png)
![image](https://user-images.githubusercontent.com/62828746/215453807-bfc10882-e0e1-402e-b967-9ab0ce6b6206.png)
![image](https://user-images.githubusercontent.com/62828746/215453844-70570f19-a46c-4f91-9f49-0076a18fc7c1.png)
![image](https://user-images.githubusercontent.com/62828746/215453891-a0ff19bb-ad17-48e8-b28c-546094b91ba7.png)

</details> 
 
<details><summary> Review floorplan files and steps to view floorplan </summary>
![image](https://user-images.githubusercontent.com/62828746/215453949-4fd1a600-e8bd-429f-9550-ac7a021f2478.png)

</details>    

<details><summary> Review floorplan layout in Magic </summary>

![image](https://user-images.githubusercontent.com/62828746/215454112-3a3b8467-2bb5-4469-b34e-d18d10277bd3.png)
![image](https://user-images.githubusercontent.com/62828746/215454169-426a31a7-292e-4171-801e-abacd5c577d0.png)
![image](https://user-images.githubusercontent.com/62828746/215454333-172599f1-583f-4f8a-b91f-17eece44daeb.png)
![image](https://user-images.githubusercontent.com/62828746/215454397-f123a29f-64e5-483b-9dae-24ee10c4e456.png)

</details> 
  
 
<details><summary> Congestion aware placement using RePlAce </summary>

![image](https://user-images.githubusercontent.com/62828746/215454517-bf06461c-a179-4e41-bbf6-98fbf5d4feb0.png)
![image](https://user-images.githubusercontent.com/62828746/215454575-8907b733-2637-4456-a777-c3977327ab38.png)
![image](https://user-images.githubusercontent.com/62828746/215454880-65bc0838-84c0-4e19-859e-c03aa5080c05.png)


</details>  
 
 
 
 
## :bookmark: Day 17  - Design library cell using Magic Layout and ngspice characterization
### :bulb: Theory - Labs for CMOS inverter ngspice simulations

<details><summary> SPICE deck creation for CMOS inverter </summary>
 
</details> 
 
<details><summary> Switching Threshold Vm </summary>
 
</details> 
 
<details><summary> Static and dynamic simulation of CMOS inverter </summary>
 
</details> 
 
### :bulb: Theory - Inception of Layout Â CMOS fabrication process
 
<details><summary>  Create Active regions </summary>
 
</details> 
 
<details><summary> Formation of N-well and P-well </summary>
 
</details> 
 
<details><summary> Formation of gate terminal </summary>
 
</details> 

<details><summary> Lightly doped drain (LDD) formation </summary>
 
</details> 
 
<details><summary>  Source Â drain formation </summary>
 
</details> 
  
<details><summary> Local interconnect formation </summary>
 
</details> 
 
<details><summary> Higher level metal formation </summary>
 
</details> 
 
 
### :pencil2: Lab -  Labs for CMOS inverter ngspice simulations

<details><summary>  IO placer revision </summary>

![image](https://user-images.githubusercontent.com/62828746/215456123-daa8e363-ea92-464d-9f39-1ba50d6ae918.png)
![image](https://user-images.githubusercontent.com/62828746/215456347-6602cb50-2d09-4d6e-a26c-6ab3b8d82006.png)

</details> 

<details><summary> Lab steps to git clone vsdstdcelldesign </summary>

![image](https://user-images.githubusercontent.com/62828746/215456975-4c2fe249-3731-4387-a951-1001414ee97b.png)

</details> 
 
### :pencil2: Lab -  Inception of Layout Â CMOS fabrication process
<details><summary> Lab introduction to Sky130 basic layers layout and LEF using inverter </summary>

![image](https://user-images.githubusercontent.com/62828746/215457844-c606b31b-fcfa-409e-b8b1-ca8fab58f94d.png)
![image](https://user-images.githubusercontent.com/62828746/215458506-4b5cf7b3-9a0e-4ce4-9b7f-52d305b1d2dc.png)
![image](https://user-images.githubusercontent.com/62828746/215459445-a6ce83e3-a558-49d3-8fbb-441761b7963b.png)

LEF only have metal layer, no information on logic path, only provide info on boundary/cell/length to place a cell 
-> Cell LEF - It's an abstract view of the cell and only gives information about PR boundary, pin position and metal layer information of the cell.
 
Can refer this github link for introduction on LEF: https://github.com/nickson-jose/vsdstdcelldesign#introduction-to-lef![image](https://user-images.githubusercontent.com/62828746/215459485-e76a789c-5b15-4710-a553-f804b12b4cbf.png)

![image](https://user-images.githubusercontent.com/62828746/215459712-37ada681-8975-4894-925c-510174d9392a.png)

</details> 

<details><summary> Lab steps to create std cell layout and extract spice netlist </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215459945-4dd5b125-20e7-4439-a3d6-32250c4c70d8.png)
![image](https://user-images.githubusercontent.com/62828746/215460060-06a55c10-534f-46f0-9a1f-38ed49195935.png)
![image](https://user-images.githubusercontent.com/62828746/215460227-c66a28bb-03e3-4650-bd46-20260e623e20.png)
![image](https://user-images.githubusercontent.com/62828746/215460291-5bd8a03f-9f0f-4476-8e6e-4a10d735d653.png)
![image](https://user-images.githubusercontent.com/62828746/215460330-a8a3157f-0162-42ee-b784-1e63bf1dc052.png)
![image](https://user-images.githubusercontent.com/62828746/215460647-9cba4d7a-a747-470c-8e58-88435827c61a.png)

</details> 

### :pencil2: Lab - Sky130 Tech File Labs
<details><summary> Lab steps to create final SPICE deck using Sky130 tech </summary>

![image](https://user-images.githubusercontent.com/62828746/215460795-f3655e1d-fc8b-44b3-8947-99fedebc4ba7.png)
![image](https://user-images.githubusercontent.com/62828746/215460995-160231de-4b64-4d54-9894-901137e00c48.png)
![image](https://user-images.githubusercontent.com/62828746/215461518-a9037109-d6c2-4fcf-8425-be6d48b62e37.png)
+ **Cell characterization means find value of 4 parameters:**
  * Rise transition: time taken for the output waveform to transit from 20% of maximum value to 80% of maximum value (VDD).
  * Fall transition: time taken for the output to fall from 80% to 20%.
  * Cell rise/fall delay/propagation delay: is a time difference where the output is rising/falling 50%.
![image](https://user-images.githubusercontent.com/62828746/215461820-ecbdd392-c758-4bba-a21f-e975194f44c0.png)

</details> 
 

   
<details><summary> Lab introduction to Magic tool options and DRC rules </summary>

To know more about open circuit design: 
Refer page: http://opencircuitdesign.com/
![image](https://user-images.githubusercontent.com/62828746/214840887-45ed4c16-0771-4dd8-b2a6-288aafd423db.png)

To know more about magic/tutorial of magic tool:
Refer page: http://opencircuitdesign.com/magic/index.html
![image](https://user-images.githubusercontent.com/62828746/214842473-8ce8030c-ea3e-4c3b-9e6f-713a12be96c2.png)

To know more about magic/tutorial of DRC in magic tool:
Refer page: http://opencircuitdesign.com/magic/tutorials/tut6.html
![image](https://user-images.githubusercontent.com/62828746/214848344-ad46328f-7e33-475f-9bd8-05a31ef80cbf.png)

${\color{lightgreen}What \space is \space Magic?}$
* Magic is a venerable VLSI layout tool, written in the 1980's at Berkeley by John Ousterhout, now famous primarily for writing the scripting interpreter language Tcl.
* Magic is widely cited as being the easiest tool to use for circuit layout, even for people who ultimately rely on commercial tools for their product design flow.
 
${\color{lightgreen}DRC \space}$
* To recheck the area underneath the box, and print out the reasons for any violations that were found. It will rechecks the entire area under the box, so it may take a long time if the box is very large. </br>
*drc why*
*  To help locate the errors, select a cell and then use the command. </br>
*drc find*
* To find out about errors in a design that wasn't created with Magic, you must force Magic to recheck everything in the design. Once this global recheck has been done, Magic will use its continuous checker to deal with any changes you make to the design; you should only need to do the global recheck once. To make the global recheck, load your design, place the box around the entire design, and type </br>
*drc check*
* To turn the checker off altogether, there is a check button on the left side of the title bar. Click on the checkbutton to stop the DRC checker. Click it again to restart. Unselecting the checkbutton is equivalent to typing the command.  </br>
*drc off*
* Run the checker and wait until everything has been rechecked and errors are completely up to date. When the command completes, the checker will still be enabled or disabled just as it was before the command. </br>
*drc catchup*
* To turn the checker back on permanently, invoke the command. </br>
*drc on*
 
${\color{lightgreen}What \space is \space CIF \space and \space GDS?}$
* CIF (Caltech Intermediate Form) and GDSII (GDS) Stream Format are standard layout description languages used to transfer mask-level layouts between organizations and design tools. 
* Magic can be used to read and write files in CIF and GDS formats.
* To write out a CIF file, place the cursor over a layout window and type the command. This will generate a CIF file called name.cif, where name is the name of the root cell in the window. </br>
*cif*
* If you wish to use a name different from the root cell, type the command. This will store the CIF in file.cif. </br>
*cif write file*
* To read a CIF file into Magic, place the cursor over a layout window and type the command. This will read the file file.cif (which must be in CIF format), generate Magic cells for the hierarchy described in the file, make the entire hierarchy a subcell of the edit cell, and run the design-rule checker to verify everything read from the file. Information in the top-level cell (usually just a call on the "main" cell of the layout) will be placed into the edit cell. </br>
*cif read file*
* To read and write GDS-format files, use the commands. </br>
*gds read gds write*
 
 
   </details> 
   
   
<details><summary> Lab introduction to Sky130 pdk's and steps to download labs </summary>

To refer SkyWater Open Source PDK documents: 
Refer page: https://skywater-pdk.readthedocs.io/en/main/
![image](https://user-images.githubusercontent.com/62828746/214856047-1c8057da-c65d-4861-b4f3-c0ae861cb39c.png)
or refer github: https://github.com/google/skywater-pdk
![image](https://user-images.githubusercontent.com/62828746/214856604-706d04d7-ae35-453d-8973-b0f6f15d6f92.png)

![image](https://user-images.githubusercontent.com/62828746/215462622-d31759e0-45b8-471d-9b38-7b288c0d2b79.png)
![image](https://user-images.githubusercontent.com/62828746/215462712-07a8d8da-86b9-4faa-99b4-98d855361576.png)
![image](https://user-images.githubusercontent.com/62828746/215462753-f99fdf6e-cc12-4889-891c-7fa21f2f73d7.png)


   </details> 


<details><summary> Lab introduction to Magic and steps to load Sky130 tech-rules </summary>

To refer Periphery Rules	: 
Refer page: https://skywater-pdk.readthedocs.io/en/main/rules/periphery.html
![image](https://user-images.githubusercontent.com/62828746/214856886-691472aa-7535-411f-a438-32d3bd93fb1d.png)

![image](https://user-images.githubusercontent.com/62828746/215462926-a7b0b193-2407-498c-96e8-ca7a9f3c1411.png)
![image](https://user-images.githubusercontent.com/62828746/215463102-16fa6909-3f76-4759-b10a-e406ed06c9dc.png)
![image](https://user-images.githubusercontent.com/62828746/215463278-efd461e9-4cb7-4a4a-8943-72a8ff399dd3.png)
![image](https://user-images.githubusercontent.com/62828746/215463403-f3017a80-66a3-48b6-a774-a6b0e6506c6e.png)
![image](https://user-images.githubusercontent.com/62828746/215463483-7eb07c58-66b8-44c7-8c37-671aa4b207e2.png)
![image](https://user-images.githubusercontent.com/62828746/215463561-bd1ab772-da82-498d-8049-8297a36ddd86.png)

 
   </details> 

<details><summary> Lab exercise to fix poly.9 error in Sky130 tech-file </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215463763-46c7876c-0e94-4f6f-a434-90d8a9f5d163.png)
![image](https://user-images.githubusercontent.com/62828746/215463909-3b62bcf4-1d15-48b5-bcda-a6f936d07d8e.png)
![image](https://user-images.githubusercontent.com/62828746/215463983-4f13a5d7-1292-4595-851e-27fc65ce3735.png)
![image](https://user-images.githubusercontent.com/62828746/215485485-b285d2f6-aae6-4f5b-befe-a4263c6f98ee.png)
![image](https://user-images.githubusercontent.com/62828746/215485633-a730db23-575b-4e5a-ab4c-739b6b24e820.png)

   </details> 
   
<details><summary> Lab exercise to implement poly resistor spacing to diff and tap </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215485750-6b77c55e-56c0-47ac-87eb-6b1ad8ef4933.png)

   </details> 

<details><summary>  Lab challenge exercise to describe DRC error as geometrical construct </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215486048-3d36e9ac-aab8-459d-b113-ccc7abbcbf72.png)
![image](https://user-images.githubusercontent.com/62828746/215486215-5e23ccbc-5e39-4324-a71e-471ee26c9e79.png)
![image](https://user-images.githubusercontent.com/62828746/215486278-84f308d2-edef-4b8b-bbd5-3f2c0fe8111c.png)
![image](https://user-images.githubusercontent.com/62828746/215486468-bfcd3887-536b-435d-9663-77dc7ef2eec4.png)
![image](https://user-images.githubusercontent.com/62828746/215486569-faad37bd-2f04-4e5c-b853-ef173d91a57f.png)
![image](https://user-images.githubusercontent.com/62828746/215486650-eda651fc-9cb4-45fc-93a2-cd9032c42b60.png)
![image](https://user-images.githubusercontent.com/62828746/215486758-66ad8213-1b29-4c47-a811-6cb734b7ba33.png)

   </details> 

<details><summary>  Lab challenge to find missing or incorrect rules and fix them </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215486979-5f3ea29c-e1e4-4f4e-8d7b-6c9a6b49b884.png)
![image](https://user-images.githubusercontent.com/62828746/215487234-ee5e4510-0f3c-4cf0-a301-df0b0afbea14.png)

   </details> 






## :bookmark: Day 18  - Pre-layout timing analysis and importance of good clock tree
### :bulb: Theory - Timing modelling using delay tables
 
<details><summary> Introduction to delay tables </summary>
 
</details> 
 
<details><summary> Delay table usage Part 1 </summary>
 
</details> 
 
<details><summary> Delay table usage Part 2 </summary>
 
</details> 
 
### :bulb: Theory - Timing analysis with ideal clocks using openSTA

<details><summary> Setup timing analysis and introduction to flip-flop setup time </summary>
 
</details> 

<details><summary>  Introduction to clock jitter and uncertainty </summary>
 
</details> 

### :bulb: Theory - Clock tree synthesis TritonCTS and signal integrity
<details><summary> Clock tree routing and buffering using H-Tree algorithm </summary>
 
</details> 

<details><summary> Crosstalk and clock net shielding </summary>
 
</details> 

### :bulb: Theory - Timing analysis with real clocks using openSTA

<details><summary> Setup timing analysis using real clocks </summary>
 
</details> 



### :pencil2: Lab - Timing modelling using delay tables

<details><summary> Lab steps to convert grid info to track info </summary>

* LEF is an ASCII representation of the abstract of standard cell.
* LEF file contains all physical information of the cells (technology and macro) and nets. It also contains Layer definition, Via’s definition, Site definition, Metal capacitance definitions, Macro cell definition, Layout of pins, Blockage information, DRC information given by foundry and etc.

![image](https://user-images.githubusercontent.com/62828746/215488174-ab9956d6-3869-4d02-80da-6f0dcd1067cd.png)
![image](https://user-images.githubusercontent.com/62828746/215492715-f6fdea32-1671-4061-a7e3-5c02ccd38065.png)
![image](https://user-images.githubusercontent.com/62828746/215492809-3a2048f4-6e48-400c-8ed0-c063ffa362a8.png)

</details> 


<details><summary> Lab steps to convert magic layout to std cell LEF </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215493276-ef470c8c-0c49-403e-afcb-f426714a05b9.png)
![image](https://user-images.githubusercontent.com/62828746/215493374-6a44ec95-eaf2-4f2f-9f39-eb2729083bd3.png)
![image](https://user-images.githubusercontent.com/62828746/215493604-ee664974-fc0c-4048-a307-89dc7c77ebba.png)


</details> 

<details><summary> Introduction to timing libs and steps to include new cell in synthesis </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215493897-c7fd1bfd-0965-4795-a676-5e6f677c795f.png)
![image](https://user-images.githubusercontent.com/62828746/215494037-3846ca8a-f430-48c5-9c03-b87ac8da9358.png)
![image](https://user-images.githubusercontent.com/62828746/215494463-df7bb8c6-f853-4b56-991e-ee261febdf33.png)
![image](https://user-images.githubusercontent.com/62828746/215494508-1955b165-e246-48f6-88cd-13e4a36c7cdf.png)

</details> 


<details><summary> Lab steps to configure synthesis settings to fix slack and include vsdinv </summary>

![image](https://user-images.githubusercontent.com/62828746/215495176-676832af-04a6-4c7b-850b-09e3c7003c0a.png)
![image](https://user-images.githubusercontent.com/62828746/215495553-dd7558b2-ebde-4d8c-bf36-74dea8845724.png)
![image](https://user-images.githubusercontent.com/62828746/215495797-f6ad6c87-b5d7-4d12-8bee-1241f77af6b0.png)
![image](https://user-images.githubusercontent.com/62828746/215496047-b36bacc3-3140-4e4e-a418-3fd8ca2f2d09.png)

</details> 


### :pencil2: Lab - Timing analysis with ideal clocks using openSTA
<details><summary> Lab steps to configure OpenSTA for post-synth timing analysis </summary>

![image](https://user-images.githubusercontent.com/62828746/215496865-71b1940e-5248-47ba-9366-beb61494c3ec.png)
![image](https://user-images.githubusercontent.com/62828746/215496928-fe39cf26-0d80-44b2-9513-df9bd603ccef.png)
![image](https://user-images.githubusercontent.com/62828746/215497001-e370c0fa-741d-4880-a333-3d9ac1071d6c.png)

 </details> 
 
<details><summary> Lab steps to optimize synthesis to reduce setup violations </summary>

![image](https://user-images.githubusercontent.com/62828746/215497206-007ce333-1528-4af4-87f5-c767ceb780a8.png)
![image](https://user-images.githubusercontent.com/62828746/215497254-e8cfb0d1-859b-4a86-8044-b03065a06e93.png)
![image](https://user-images.githubusercontent.com/62828746/215497416-f8aa35c3-dd52-4f60-9d47-b5f1791f9ff4.png)

 </details> 
 
<details><summary> Lab steps to do basic timing ECO </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215497801-c68ec081-e456-4412-bf8d-0807fda5023a.png)

 </details>

### :pencil2: Lab - Clock tree synthesis TritonCTS and signal integrity

<details><summary> Lab steps to run CTS using TritonCTS </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215498961-796d83cd-f14a-4152-9f54-7ff103d903fb.png)

 </details>
 
<details><summary> Lab steps to verify CTS runs </summary>

![image](https://user-images.githubusercontent.com/62828746/215499202-a8b8f066-c084-4802-bc7a-3919956d18bb.png
![image](https://user-images.githubusercontent.com/62828746/215499278-3b02906f-7b96-4a01-abd5-354faa7bf602.png)

 </details>
 
### :pencil2: Lab- Timing analysis with real clocks using openSTA

<details><summary> Lab steps to analyze timing with real clocks using OpenSTA </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215499810-78a8c4c2-7012-4244-8c5a-205f42280633.png)
![image](https://user-images.githubusercontent.com/62828746/215500037-f5f941b7-0fc4-4f42-9608-624a5a9fa9a2.png)

 </details>

<details><summary> Lab steps to execute OpenSTA with right timing libraries and CTS assignment </summary>

![image](https://user-images.githubusercontent.com/62828746/215500508-cc44905a-0bb5-46d9-b12a-bdd2a6591b59.png)

 </details>


<details><summary> Lab steps to observe impact of bigger CTS buffers on setup and hold timing </summary>

![image](https://user-images.githubusercontent.com/62828746/215500740-485ba8f2-ebb4-44e4-924a-5f7842254fd0.png)
![image](https://user-images.githubusercontent.com/62828746/215500814-156f0ecf-154f-462a-8767-b7396148badc.png)


 </details>


## :bookmark: Day 19  - Final steps for RTL2GDS using tritonRoute and openSTA
### :bulb: Theory - Routing and design rule check (DRC)
 
<details><summary> Introduction to Maze Routing Â LeeÂs algorithm </summary>
 
</details> 

<details><summary> LeeÂs Algorithm conclusion </summary>
 
</details> 

<details><summary> Design Rule Check </summary>
 
</details> 

### :bulb: Theory - TritonRoute Features
<details><summary> TritonRoute feature 1 - Honors pre-processed route guides </summary>
 
</details> 

<details><summary> TritonRoute Feature2 & 3 - Inter-guide connectivity and intra- & inter-layer routing </summary>
 
</details> 

<details><summary> TritonRoute method to handle connectivity </summary>
 
</details> 

### :pencil2: Lab - Power Distribution Network and routing
<details><summary> Lab steps to build power distribution network </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215501812-972fb45d-9741-45bf-a6a0-dab46c76c93b.png)
![image](https://user-images.githubusercontent.com/62828746/215501946-0a02d61b-be52-4595-86bc-ad8637262d00.png)
![image](https://user-images.githubusercontent.com/62828746/215502191-8b2706a0-2103-447f-882f-62c4eea01cf3.png)
![image](https://user-images.githubusercontent.com/62828746/215502252-6d640ae6-8509-4861-b104-f7154f149f29.png)
![image](https://user-images.githubusercontent.com/62828746/215502357-19be35f1-75b4-490f-9a06-3bc2d3be9f60.png)

</details> 

<details><summary> Lab steps from power straps to std cell power </summary>

![image](https://user-images.githubusercontent.com/62828746/215502612-d925fad7-53ce-4fc9-9ed9-7cc58f1ccf45.png)
![image](https://user-images.githubusercontent.com/62828746/215503041-daab362c-a32e-4285-b196-6966ccb40286.png)
![image](https://user-images.githubusercontent.com/62828746/215503168-42a2d44d-976a-4671-ac34-6e8971cdaf37.png)

</details> 


<details><summary> Basics of global and detail routing and configure TritonRoute </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215504141-dac43371-b6d2-4cbe-b8d8-bea85092dc46.png)

</details> 

<details><summary> Basics of global and detail routing and configure TritonRoute </summary>
 
![image](https://user-images.githubusercontent.com/62828746/215504141-dac43371-b6d2-4cbe-b8d8-bea85092dc46.png)

</details> 

### :pencil2: Lab - TritonRoute Features

<details><summary> Routing topology algorithm and final files list post-route </summary>

![image](https://user-images.githubusercontent.com/62828746/215505600-de29d478-6431-403d-b337-726cb87dc685.png)
![image](https://user-images.githubusercontent.com/62828746/215505912-e3eb109b-f01c-460f-b6b9-c25b3ee92f5b.png)
![image](https://user-images.githubusercontent.com/62828746/215506012-c010e2ea-c268-49b0-9d55-c9a49e32ea21.png)
![image](https://user-images.githubusercontent.com/62828746/215506066-2404ad74-8e74-4740-8117-0d167fd93937.png)
 
</details> 


